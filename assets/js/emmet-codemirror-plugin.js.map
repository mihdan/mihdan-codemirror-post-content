{"version":3,"file":"emmet-codemirror-plugin.js","sources":["../node_modules/@emmetio/extract-abbreviation/dist/extract-abbreviation.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/output-profile/dist/output-profile.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/node/dist/node.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/stream-reader-utils/dist/stream-reader-utils.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/abbreviation/dist/abbreviation.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/html-snippets-resolver/dist/html-snippets-resolver.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/implicit-tag/dist/implicit-tag.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/html-transform/dist/html-transform.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/variable-resolver/dist/variable-resolver.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/field-parser/dist/field-parser.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/output-renderer/dist/output-renderer.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/markup-formatters/dist/markup-formatters.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/css-abbreviation/dist/css-abbreviation.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/css-snippets-resolver/dist/css-snippets-resolver.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/stylesheet-formatters/dist/stylesheet-formatters.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/lorem/dist/lorem.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/dist/expand.es.js","../lib/detect-syntax.js","../lib/utils.js","../lib/expand-abbreviation.js","../lib/abbreviation-marker.js","../node_modules/@emmetio/css-snippets-resolver/dist/css-snippets-resolver.es.js","../lib/autocomplete.js","../../html-matcher/node_modules/@emmetio/stream-reader-utils/dist/stream-reader-utils.es.js","../../html-matcher/dist/html-matcher.es.js","../lib/model/syntax-model.js","../lib/model/html.js","../lib/model/index.js","../lib/match-tag.js","../lib/rename-tag.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/snippets-registry/dist/snippets-registry.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/stream-reader/dist/stream-reader.es.js","../../../../../../usr/local/lib/node_modules/@emmetio/expand-abbreviation/node_modules/@emmetio/snippets/dist/snippets.es.js","../lib/commands/expand-abbreviation.js","../lib/commands/formatted-line-break.js","../../stream-reader/dist/stream-reader.es.js","../node_modules/@emmetio/stream-reader/dist/stream-reader.es.js","../lib/stream-reader.js","../extension.js","../browser.js"],"sourcesContent":["/**\n * Minimalistic backwards stream reader\n */\nclass StreamReader {\n\tconstructor(string) {\n\t\tthis.string = string;\n\t\tthis.pos = this.string.length;\n\t}\n\n\tsol() {\n\t\treturn this.pos === 0;\n\t}\n\n\tpeek(offset) {\n\t\treturn this.string.charCodeAt(this.pos - 1 + (offset || 0));\n\t}\n\n\tprev() {\n\t\tif (!this.sol()) {\n\t\t\treturn this.string.charCodeAt(--this.pos);\n\t\t}\n\t}\n\n\teat(match) {\n\t\tconst ok = typeof match === 'function'\n\t\t\t? match(this.peek())\n\t\t\t: match === this.peek();\n\n\t\tif (ok) {\n\t\t\tthis.pos--;\n\t\t}\n\n\t\treturn ok;\n\t}\n\n\teatWhile(match) {\n\t\tconst start = this.pos;\n\t\twhile (this.eat(match)) {}\n\t\treturn this.pos < start;\n\t}\n}\n\n/**\n * Quotes-related utilities\n */\n\nconst SINGLE_QUOTE = 39; // '\nconst DOUBLE_QUOTE = 34; // \"\nconst ESCAPE       = 92; // \\\n\n/**\n * Check if given character code is a quote\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isQuote(c) {\n\treturn c === SINGLE_QUOTE || c === DOUBLE_QUOTE;\n}\n\n/**\n * Consumes quoted value, if possible\n * @param  {StreamReader} stream\n * @return {Boolean}      Returns `true` is value was consumed\n */\nfunction eatQuoted(stream) {\n\tconst start = stream.pos;\n\tconst quote = stream.prev();\n\n\tif (isQuote(quote)) {\n\t\twhile (!stream.sol()) {\n\t\t\tif (stream.prev() === quote && stream.peek() !== ESCAPE) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\nconst TAB         = 9;\nconst SPACE       = 32;\nconst SLASH       = 47; // /\nconst COLON       = 58; // :\nconst EQUALS      = 61; // =\nconst ANGLE_LEFT  = 60; // <\nconst ANGLE_RIGHT = 62; // >\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nvar isAtHTMLTag = function(stream) {\n\tconst start = stream.pos;\n\n\tif (!stream.eat(ANGLE_RIGHT)) {\n\t\treturn false;\n\t}\n\n\tlet ok = false;\n\tstream.eat(SLASH); // possibly self-closed element\n\n\twhile (!stream.sol()) {\n\t\tstream.eatWhile(isWhiteSpace);\n\n\t\tif (eatIdent(stream)) {\n\t\t\t// ate identifier: could be a tag name, boolean attribute or unquoted\n\t\t\t// attribute value\n\t\t\tif (stream.eat(SLASH)) {\n\t\t\t\t// either closing tag or invalid tag\n\t\t\t\tok = stream.eat(ANGLE_LEFT);\n\t\t\t\tbreak;\n\t\t\t} else if (stream.eat(ANGLE_LEFT)) {\n\t\t\t\t// opening tag\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t} else if (stream.eat(isWhiteSpace)) {\n\t\t\t\t// boolean attribute\n\t\t\t\tcontinue;\n\t\t\t} else if (stream.eat(EQUALS)) {\n\t\t\t\t// simple unquoted value or invalid attribute\n\t\t\t\tok = eatIdent(stream);\n\t\t\t\tbreak;\n\t\t\t} else if (eatAttributeWithUnquotedValue(stream)) {\n\t\t\t\t// identifier was a part of unquoted value\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// invalid tag\n\t\t\tbreak;\n\t\t}\n\n\t\tif (eatAttribute(stream)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tstream.pos = start;\n\treturn ok;\n};\n\n/**\n * Eats HTML attribute from given string.\n * @param  {StreamReader} state\n * @return {Boolean}       `true` if attribute was consumed.\n */\nfunction eatAttribute(stream) {\n\treturn eatAttributeWithQuotedValue(stream) || eatAttributeWithUnquotedValue(stream);\n}\n\n/**\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatAttributeWithQuotedValue(stream) {\n\tconst start = stream.pos;\n\tif (eatQuoted(stream) && stream.eat(EQUALS) && eatIdent(stream)) {\n\t\treturn true;\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\n/**\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatAttributeWithUnquotedValue(stream) {\n\tconst start = stream.pos;\n\tif (stream.eatWhile(isUnquotedValue) && stream.eat(EQUALS) && eatIdent(stream)) {\n\t\treturn true;\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\n/**\n * Eats HTML identifier from stream\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatIdent(stream) {\n\treturn stream.eatWhile(isIdent);\n}\n\n/**\n * Check if given character code belongs to HTML identifier\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isIdent(c) {\n\treturn c === COLON || isAlpha(c) || isNumber(c);\n}\n\n/**\n * Check if given character code is alpha code (letter though A to Z)\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isAlpha(c) {\n\tc &= ~32; // quick hack to convert any char code to uppercase char code\n\treturn c >= 65 && c <= 90; // A-Z\n}\n\n/**\n * Check if given code is a number\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isNumber(c) {\n\treturn c > 47 && c < 58;\n}\n\n/**\n * Check if given code is a whitespace\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isWhiteSpace(c) {\n\treturn c === SPACE || c === TAB;\n}\n\n/**\n * Check if given code may belong to unquoted attribute value\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isUnquotedValue(c) {\n\treturn c && c !== EQUALS && !isWhiteSpace(c) && !isQuote(c);\n}\n\nconst code = ch => ch.charCodeAt(0);\nconst SQUARE_BRACE_L = code('[');\nconst SQUARE_BRACE_R = code(']');\nconst ROUND_BRACE_L  = code('(');\nconst ROUND_BRACE_R  = code(')');\nconst CURLY_BRACE_L  = code('{');\nconst CURLY_BRACE_R  = code('}');\n\nconst specialChars = new Set('#.*:$-_!@%^+>/'.split('').map(code));\nconst bracePairs = new Map()\n.set(SQUARE_BRACE_L, SQUARE_BRACE_R)\n.set(ROUND_BRACE_L,  ROUND_BRACE_R)\n.set(CURLY_BRACE_L,  CURLY_BRACE_R);\n\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param {String}  line A text line where abbreviation should be expanded\n * @param {Number}  [pos] Caret position in line. If not given, uses end-of-line\n * @param {Boolean} [lookAhead] Allow parser to look ahead of `pos` index for\n * searching of missing abbreviation parts. Most editors automatically inserts\n * closing braces for `[`, `{` and `(`, which will most likely be right after\n * current caret position. So in order to properly expand abbreviation, user\n * must explicitly move caret right after auto-inserted braces. Whith this option\n * enabled, parser will search for closing braces right after `pos`. Default is `true`\n * @return {Object} Object with `abbreviation` and its `location` in given line\n * if abbreviation can be extracted, `null` otherwise\n */\nfunction extractAbbreviation(line, pos, lookAhead) {\n\t// make sure `pos` is within line range\n\tpos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n\n\tif (lookAhead == null || lookAhead === true) {\n\t\tpos = offsetPastAutoClosed(line, pos);\n\t}\n\n\tlet c;\n\tconst stream = new StreamReader(line);\n\tstream.pos = pos;\n\tconst stack = [];\n\n\twhile (!stream.sol()) {\n\t\tc = stream.peek();\n\n\t\tif (isCloseBrace(c)) {\n\t\t\tstack.push(c);\n\t\t} else if (isOpenBrace(c)) {\n\t\t\tif (stack.pop() !== bracePairs.get(c)) {\n\t\t\t\t// unexpected brace\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (has(stack, SQUARE_BRACE_R) || has(stack, CURLY_BRACE_R)) {\n\t\t\t// respect all characters inside attribute sets or text nodes\n\t\t\tstream.pos--;\n\t\t\tcontinue;\n\t\t} else if (isAtHTMLTag(stream) || !isAbbreviation(c)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tstream.pos--;\n\t}\n\n\tif (!stack.length && stream.pos !== pos) {\n\t\t// found something, remove some invalid symbols from the\n\t\t// beginning and return abbreviation\n\t\tconst abbreviation = line.slice(stream.pos, pos).replace(/^[\\*\\+\\>\\^]+/, '');\n\t\treturn {\n\t\t\tabbreviation,\n\t\t\tlocation: pos - abbreviation.length\n\t\t};\n\t}\n}\n\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * edditor will likely automatically close, e.g. }, ], and quotes\n * @param {String} line\n * @param {Number} pos\n * @return {Number}\n */\nfunction offsetPastAutoClosed(line, pos) {\n\t// closing quote is allowed only as a next character\n\tif (isQuote(line.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\t// offset pointer until non-autoclosed character is found\n\twhile (isCloseBrace(line.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\treturn pos;\n}\n\nfunction has(arr, value) {\n\treturn arr.indexOf(value) !== -1;\n}\n\nfunction isAbbreviation(c) {\n\treturn (c > 64 && c < 91)   // uppercase letter\n\t\t|| (c > 96 && c < 123)  // lowercase letter\n\t\t|| (c > 47 && c < 58)   // number\n\t\t|| specialChars.has(c); // special character\n}\n\nfunction isOpenBrace(c) {\n\treturn c === SQUARE_BRACE_L || c === ROUND_BRACE_L || c === CURLY_BRACE_L;\n}\n\nfunction isCloseBrace(c) {\n\treturn c === SQUARE_BRACE_R || c === ROUND_BRACE_R || c === CURLY_BRACE_R;\n}\n\nexport default extractAbbreviation;\n","var defaultOptions = {\n\t/**\n\t * String for one-level indentation\n\t * @type {String}\n\t */\n\tindent: '\\t',\n\n\t/**\n\t * Tag case: 'lower', 'upper' or '' (keep as-is)\n\t * @type {String}\n\t */\n\ttagCase: '',\n\n\t/**\n\t * Attribute name case: 'lower', 'upper' or '' (keep as-is)\n\t * @type {String}\n\t */\n\tattributeCase: '',\n\n\t/**\n\t * Attribute value quotes: 'single' or 'double'\n\t * @type {String}\n\t */\n\tattributeQuotes: 'double',\n\n\t/**\n\t * Enable output formatting (indentation and line breaks)\n\t * @type {Boolean}\n\t */\n\tformat: true,\n\n\t/**\n\t * A list of tag names that should not get inner indentation\n\t * @type {Set}\n\t */\n\tformatSkip: ['html'],\n\n\t/**\n\t * A list of tag names that should *always* get inner indentation.\n\t * @type {Set}\n\t */\n\tformatForce: ['body'],\n\n\t/**\n\t * How many inline sibling elements should force line break for each tag.\n\t * Set to 0 to output all inline elements without formatting.\n\t * Set to 1 to output all inline elements with formatting (same as block-level).\n\t * @type {Number}\n\t */\n\tinlineBreak: 3,\n\n\t/**\n\t * Produce compact notation of boolean attribues: attributes where name equals value.\n\t * With this option enabled, output `<div contenteditable>` instead of\n\t * `<div contenteditable=\"contenteditable\">`\n\t * @type {Boolean}\n\t */\n\tcompactBooleanAttributes: false,\n\n\t/**\n\t * A set of boolean attributes\n\t * @type {Set}\n\t */\n\tbooleanAttributes: ['contenteditable', 'seamless', 'async', 'autofocus',\n\t\t'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n\t\t'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n\t\t'required', 'reversed', 'selected', 'typemustmatch'],\n\n\t/**\n\t * Style of self-closing tags:\n\t * 'html'  – <br>\n\t * 'xml'   – <br/>\n\t * 'xhtml' – <br />\n\t * @type {String}\n\t */\n\tselfClosingStyle: 'html',\n\n\t/**\n\t * A set of inline-level elements\n\t * @type {Set}\n\t */\n\tinlineElements: ['a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n\t\t'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n\t\t'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n\t\t's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n\t\t'textarea', 'tt', 'u', 'var']\n};\n\n/**\n * Creates output profile for given options (@see defaults)\n * @param {defaults} options\n */\nclass Profile {\n    constructor(options) {\n        this.options = Object.assign({}, defaultOptions, options);\n        this.quoteChar = this.options.attributeQuotes === 'single' ? '\\'' : '\"';\n    }\n\n\t/**\n\t * Returns value of given option name\n\t * @param {String} name\n\t * @return {*}\n\t */\n\tget(name) {\n\t\treturn this.options[name];\n\t}\n\n    /**\n     * Quote given string according to profile\n     * @param {String} str String to quote\n     * @return {String}\n     */\n    quote(str) {\n        return `${this.quoteChar}${str != null ? str : ''}${this.quoteChar}`;\n    }\n\n    /**\n     * Output given tag name accoding to options\n     * @param {String} name\n     * @return {String}\n     */\n    name(name) {\n        return strcase(name, this.options.tagCase);\n    }\n\n\t/**\n\t * Outputs attribute name accoding to current settings\n\t * @param {String} Attribute name\n\t * @return {String}\n\t */\n    attribute(attr) {\n        return strcase(attr, this.options.attributeCase);\n    }\n\n    /**\n     * Check if given attribute is boolean\n     * @param {Attribute} attr\n     * @return {Boolean}\n     */\n    isBooleanAttribute(attr) {\n        return attr.options.boolean\n\t\t\t|| this.get('booleanAttributes').indexOf((attr.name || '').toLowerCase()) !== -1;\n    }\n\n\t/**\n\t * Returns a token for self-closing tag, depending on current options\n\t * @return {String}\n\t */\n\tselfClose() {\n\t\tswitch (this.options.selfClosingStyle) {\n\t\t\tcase 'xhtml': return ' /';\n\t\t\tcase 'xml':   return '/';\n\t\t\tdefault:      return '';\n\t\t}\n\t}\n\n\t/**\n\t * Returns indent for given level\n\t * @param {Number} level Indentation level\n\t * @return {String}\n\t */\n\tindent(level) {\n\t\tlevel = level || 0;\n\t\tlet output = '';\n\t\twhile (level--) {\n\t\t\toutput += this.options.indent;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Check if given tag name belongs to inline-level element\n\t * @param {Node|String} node Parsed node or tag name\n\t * @return {Boolean}\n\t */\n\tisInline(node) {\n        if (typeof node === 'string') {\n            return this.get('inlineElements').indexOf(node.toLowerCase()) !== -1;\n        }\n\n        // inline node is a node either with inline-level name or text-only node\n        return node.name != null ? this.isInline(node.name) : node.isTextOnly;\n\t}\n\n\t/**\n\t * Outputs formatted field for given params\n\t * @param {Number} index Field index\n\t * @param {String} [placeholder] Field placeholder, can be empty\n\t * @return {String}\n\t */\n\tfield(index, placeholder) {\n\t\treturn this.options.field(index, placeholder);\n\t}\n}\n\nfunction strcase(string, type) {\n    if (type) {\n        string = type === 'upper' ? string.toUpperCase() : string.toLowerCase();\n    }\n    return string;\n}\n\nexport default Profile;\n","/**\n * Attribute descriptor of parsed abbreviation node\n * @param {String} name Attribute name\n * @param {String} value Attribute value\n * @param {Object} options Additional custom attribute options\n * @param {Boolean} options.boolean Attribute is boolean (e.g. name equals value)\n * @param {Boolean} options.implied Attribute is implied (e.g. must be outputted\n * only if contains non-null value)\n */\nclass Attribute {\n\tconstructor(name, value, options) {\n\t\tthis.name = name;\n\t\tthis.value = value != null ? value : null;\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * Create a copy of current attribute\n\t * @return {Attribute}\n\t */\n\tclone() {\n\t\treturn new Attribute(this.name, this.value, Object.assign({}, this.options));\n\t}\n\n\t/**\n\t * A string representation of current node\n\t */\n\tvalueOf() {\n\t\treturn `${this.name}=\"${this.value}\"`;\n\t}\n}\n\n/**\n * A parsed abbreviation AST node. Nodes build up an abbreviation AST tree\n */\nclass Node {\n\t/**\n\t * Creates a new node\n\t * @param {String} [name] Node name\n\t * @param {Array} [attributes] Array of attributes to add\n\t */\n\tconstructor(name, attributes) {\n\t\t// own properties\n\t\tthis.name = name || null;\n\t\tthis.value = null;\n\t\tthis.repeat = null;\n\t\tthis.selfClosing = false;\n\n\t\tthis.children = [];\n\n\t\t/** @type {Node} Pointer to parent node */\n\t\tthis.parent = null;\n\n\t\t/** @type {Node} Pointer to next sibling */\n\t\tthis.next = null;\n\n\t\t/** @type {Node} Pointer to previous sibling */\n\t\tthis.previous = null;\n\n\t\tthis._attributes = [];\n\n\t\tif (Array.isArray(attributes)) {\n\t\t\tattributes.forEach(attr => this.setAttribute(attr));\n\t\t}\n\t}\n\n\t/**\n\t * Array of current node attributes\n\t * @return {Attribute[]} Array of attributes\n\t */\n\tget attributes() {\n\t\treturn this._attributes;\n\t}\n\n\t/**\n\t * A shorthand to retreive node attributes as map\n\t * @return {Object}\n\t */\n\tget attributesMap() {\n\t\treturn this.attributes.reduce((out, attr) => {\n\t\t\tout[attr.name] = attr.options.boolean ? attr.name : attr.value;\n\t\t\treturn out;\n\t\t}, {});\n\t}\n\n\t/**\n\t * Check if current node is a grouping one, e.g. has no actual representation\n\t * and is used for grouping subsequent nodes only\n\t * @return {Boolean}\n\t */\n\tget isGroup() {\n\t\treturn !this.name && !this.value && !this._attributes.length;\n\t}\n\n\t/**\n\t * Check if given node is a text-only node, e.g. contains only value\n\t * @return {Boolean}\n\t */\n\tget isTextOnly() {\n\t\treturn !this.name && !!this.value && !this._attributes.length;\n\t}\n\n\t/**\n\t * Returns first child node\n\t * @return {Node}\n\t */\n\tget firstChild() {\n\t\treturn this.children[0];\n\t}\n\n\t/**\n\t * Returns last child of current node\n\t * @return {Node}\n\t */\n\tget lastChild() {\n\t\treturn this.children[this.children.length - 1];\n\t}\n\n\t/**\n\t * Return index of current node in its parent child list\n\t * @return {Number} Returns -1 if current node is a root one\n\t */\n\tget childIndex() {\n\t\treturn this.parent ? this.parent.children.indexOf(this) : -1;\n\t}\n\n\t/**\n\t * Returns next sibling of current node\n\t * @return {Node}\n\t */\n\tget nextSibling() {\n\t\treturn this.next;\n\t}\n\n\t/**\n\t * Returns previous sibling of current node\n\t * @return {Node}\n\t */\n\tget previousSibling() {\n\t\treturn this.previous;\n\t}\n\n\t/**\n\t * Returns array of unique class names in current node\n\t * @return {String[]}\n\t */\n\tget classList() {\n\t\tconst attr = this.getAttribute('class');\n\t\treturn attr && attr.value\n\t\t\t? attr.value.split(/\\s+/g).filter(uniqueClass)\n\t\t\t: [];\n\t}\n\n\t/**\n\t * Convenient alias to create a new node instance\n\t * @param {String} [name] Node name\n\t * @param {Object} [attributes] Attributes hash\n\t * @return {Node}\n\t */\n\tcreate(name, attributes) {\n\t\treturn new Node(name, attributes);\n\t}\n\n\t/**\n\t * Sets given attribute for current node\n\t * @param {String|Object|Attribute} name Attribute name or attribute object\n\t * @param {String} [value] Attribute value\n\t */\n\tsetAttribute(name, value) {\n\t\tconst attr = createAttribute(name, value);\n\t\tconst curAttr = this.getAttribute(name);\n\t\tif (curAttr) {\n\t\t\tthis.replaceAttribute(curAttr, attr);\n\t\t} else {\n\t\t\tthis._attributes.push(attr);\n\t\t}\n\t}\n\n\t/**\n\t * Check if attribute with given name exists in node\n\t * @param  {String} name\n\t * @return {Boolean}\n\t */\n\thasAttribute(name) {\n\t\treturn !!this.getAttribute(name);\n\t}\n\n\t/**\n\t * Returns attribute object by given name\n\t * @param  {String} name\n\t * @return {Attribute}\n\t */\n\tgetAttribute(name) {\n\t\tif (typeof name === 'object') {\n\t\t\tname = name.name;\n\t\t}\n\n\t\tfor (var i = 0; i < this._attributes.length; i++) {\n\t\t\tconst attr = this._attributes[i];\n\t\t\tif (attr.name === name) {\n\t\t\t\treturn attr;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Replaces attribute with new instance\n\t * @param {String|Attribute} curAttribute Current attribute name or instance\n\t * to replace\n\t * @param {String|Object|Attribute} newName New attribute name or attribute object\n\t * @param {String} [newValue] New attribute value\n\t */\n\treplaceAttribute(curAttribute, newName, newValue) {\n\t\tif (typeof curAttribute === 'string') {\n\t\t\tcurAttribute = this.getAttribute(curAttribute);\n\t\t}\n\n\t\tconst ix = this._attributes.indexOf(curAttribute);\n\t\tif (ix !== -1) {\n\t\t\tthis._attributes.splice(ix, 1, createAttribute(newName, newValue));\n\t\t}\n\t}\n\n\t/**\n\t * Removes attribute with given name\n\t * @param  {String|Attribute} attr Atrtibute name or instance\n\t */\n\tremoveAttribute(attr) {\n\t\tif (typeof attr === 'string') {\n\t\t\tattr = this.getAttribute(attr);\n\t\t}\n\n\t\tconst ix = this._attributes.indexOf(attr);\n\t\tif (ix !== -1) {\n\t\t\tthis._attributes.splice(ix, 1);\n\t\t}\n\t}\n\n\t/**\n\t * Removes all attributes from current node\n\t */\n\tclearAttributes() {\n\t\tthis._attributes.length = 0;\n\t}\n\n\t/**\n\t * Adds given class name to class attribute\n\t * @param {String} token Class name token\n\t */\n\taddClass(token) {\n\t\ttoken = normalize(token);\n\n\t\tif (!this.hasAttribute('class')) {\n\t\t\tthis.setAttribute('class', token);\n\t\t} else if (token && !this.hasClass(token)) {\n\t\t\tthis.setAttribute('class', this.classList.concat(token).join(' '));\n\t\t}\n\t}\n\n\t/**\n\t * Check if current node contains given class name\n\t * @param {String} token Class name token\n\t * @return {Boolean}\n\t */\n\thasClass(token) {\n\t\treturn this.classList.indexOf(normalize(token)) !== -1;\n\t}\n\n\t/**\n\t * Removes given class name from class attribute\n\t * @param {String} token Class name token\n\t */\n\tremoveClass(token) {\n\t\ttoken = normalize(token);\n\t\tif (this.hasClass(token)) {\n\t\t\tthis.setAttribute('class', this.classList.filter(name => name !== token).join(' '));\n\t\t}\n\t}\n\n\t/**\n\t * Appends child to current node\n\t * @param {Node} node\n\t */\n\tappendChild(node) {\n\t\tthis.insertAt(node, this.children.length);\n\t}\n\n\t/**\n\t * Inserts given `newNode` before `refNode` child node\n\t * @param {Node} newNode\n\t * @param {Node} refNode\n\t */\n\tinsertBefore(newNode, refNode) {\n\t\tthis.insertAt(newNode, this.children.indexOf(refNode));\n\t}\n\n\t/**\n\t * Insert given `node` at `pos` position of child list\n\t * @param {Node} node\n\t * @param {Number} pos\n\t */\n\tinsertAt(node, pos) {\n\t\tif (pos < 0 || pos > this.children.length) {\n\t\t\tthrow new Error('Unable to insert node: position is out of child list range');\n\t\t}\n\n\t\tconst prev = this.children[pos - 1];\n\t\tconst next = this.children[pos];\n\n\t\tnode.remove();\n\t\tnode.parent = this;\n\t\tthis.children.splice(pos, 0, node);\n\n\t\tif (prev) {\n\t\t\tnode.previous = prev;\n\t\t\tprev.next = node;\n\t\t}\n\n\t\tif (next) {\n\t\t\tnode.next = next;\n\t\t\tnext.previous = node;\n\t\t}\n\t}\n\n\t/**\n\t * Removes given child from current node\n\t * @param {Node} node\n\t */\n\tremoveChild(node) {\n\t\tconst ix = this.children.indexOf(node);\n\t\tif (ix !== -1) {\n\t\t\tthis.children.splice(ix, 1);\n\t\t\tif (node.previous) {\n\t\t\t\tnode.previous.next = node.next;\n\t\t\t}\n\n\t\t\tif (node.next) {\n\t\t\t\tnode.next.previous = node.previous;\n\t\t\t}\n\n\t\t\tnode.parent = node.next = node.previous = null;\n\t\t}\n\t}\n\n\t/**\n\t * Removes current node from its parent\n\t */\n\tremove() {\n\t\tif (this.parent) {\n\t\t\tthis.parent.removeChild(this);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a detached copy of current node\n\t * @param {Boolean} deep Clone node contents as well\n\t * @return {Node}\n\t */\n\tclone(deep) {\n\t\tconst clone = new Node(this.name);\n\t\tclone.value = this.value;\n\t\tclone.selfClosing = this.selfClosing;\n\t\tif (this.repeat) {\n\t\t\tclone.repeat = Object.assign({}, this.repeat);\n\t\t}\n\n\t\tthis._attributes.forEach(attr => clone.setAttribute(attr.clone()));\n\n\t\tif (deep) {\n\t\t\tthis.children.forEach(child => clone.appendChild(child.clone(true)));\n\t\t}\n\n\t\treturn clone;\n\t}\n\n\t/**\n\t * Walks on each descendant node and invokes given `fn` function on it.\n\t * The function receives two arguments: the node itself and its depth level\n\t * from current node. If function returns `false`, it stops walking\n\t * @param {Function} fn\n\t */\n\twalk(fn, _level) {\n\t\t_level = _level || 0;\n\t\tlet ctx = this.firstChild;\n\n\t\twhile (ctx) {\n\t\t\t// in case if context node will be detached during `fn` call\n\t\t\tconst next = ctx.next;\n\n\t\t\tif (fn(ctx, _level) === false || ctx.walk(fn, _level + 1) === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tctx = next;\n\t\t}\n\t}\n\n\t/**\n\t * A helper method for transformation chaining: runs given `fn` function on\n\t * current node and returns the same node\n\t */\n\tuse(fn) {\n\t\tconst args = [this];\n\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\targs.push(arguments[i]);\n\t\t}\n\n\t\tfn.apply(null, args);\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst attrs = this.attributes.map(attr => {\n\t\t\tattr = this.getAttribute(attr.name);\n\t\t\tconst opt = attr.options;\n\t\t\tlet out = `${opt && opt.implied ? '!' : ''}${attr.name || ''}`;\n\t\t\tif (opt && opt.boolean) {\n\t\t\t\tout += '.';\n\t\t\t} else if (attr.value != null) {\n\t\t\t\tout += `=\"${attr.value}\"`;\n\t\t\t}\n\t\t\treturn out;\n\t\t});\n\n\t\tlet out = `${this.name || ''}`;\n\t\tif (attrs.length) {\n\t\t\tout += `[${attrs.join(' ')}]`;\n\t\t}\n\n\t\tif (this.value != null) {\n\t\t\tout += `{${this.value}}`;\n\t\t}\n\n\t\tif (this.selfClosing) {\n\t\t\tout += '/';\n\t\t}\n\n\t\tif (this.repeat) {\n\t\t\tout += `*${this.repeat.count ? this.repeat.count : ''}`;\n\t\t\tif (this.repeat.value != null) {\n\t\t\t\tout += `@${this.repeat.value}`;\n\t\t\t}\n\t\t}\n\n\t\treturn out;\n\t}\n}\n\n/**\n * Attribute factory\n * @param  {String|Attribute|Object} name  Attribute name or attribute descriptor\n * @param  {*} value Attribute value\n * @return {Attribute}\n */\nfunction createAttribute(name, value) {\n\tif (name instanceof Attribute) {\n\t\treturn name;\n\t}\n\n\tif (typeof name === 'string') {\n\t\treturn new Attribute(name, value);\n\t}\n\n\tif (name && typeof name === 'object') {\n\t\treturn new Attribute(name.name, name.value, name.options);\n\t}\n}\n\n/**\n * @param  {String} str\n * @return {String}\n */\nfunction normalize(str) {\n\treturn String(str).trim();\n}\n\nfunction uniqueClass(item, i, arr) {\n\treturn item && arr.indexOf(item) === i;\n}\n\nexport default Node;\n","/**\n * Methods for consuming quoted values\n */\n\nconst SINGLE_QUOTE = 39; // '\nconst DOUBLE_QUOTE = 34; // \"\n\nconst defaultOptions = {\n\tescape: 92,   // \\ character\n\tthrows: false\n};\n\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @param  {StreamReader} stream\n * @param  {Number}  options.escape A character code of quote-escape symbol\n * @param  {Boolean} options.throws Throw error if quotes string can’t be properly consumed\n * @return {Boolean} `true` if quoted string was consumed. The contents\n *                   of quoted string will be availabe as `stream.current()`\n */\nvar eatQuoted = function(stream, options) {\n\toptions = options ? Object.assign({}, defaultOptions, options) : defaultOptions;\n\tconst start = stream.pos;\n\tconst quote = stream.peek();\n\n\tif (stream.eat(isQuote)) {\n\t\twhile (!stream.eof()) {\n\t\t\tswitch (stream.next()) {\n\t\t\t\tcase quote:\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn true;\n\n\t\t\t\tcase options.escape:\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then stream wasn’t properly consumed.\n\t\t// Revert stream and decide what to do\n\t\tstream.pos = start;\n\n\t\tif (options.throws) {\n\t\t\tthrow stream.error('Unable to consume quoted string');\n\t\t}\n\t}\n\n\treturn false;\n};\n\nfunction isQuote(code) {\n\treturn code === SINGLE_QUOTE || code === DOUBLE_QUOTE;\n}\n\n/**\n * Check if given code is a number\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isNumber(code) {\n\treturn code > 47 && code < 58;\n}\n\n/**\n * Check if given character code is alpha code (letter through A to Z)\n * @param  {Number}  code\n * @param  {Number}  [from]\n * @param  {Number}  [to]\n * @return {Boolean}\n */\nfunction isAlpha(code, from, to) {\n\tfrom = from || 65; // A\n\tto   = to   || 90; // Z\n\tcode &= ~32; // quick hack to convert any char code to uppercase char code\n\n\treturn code >= from && code <= to;\n}\n\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaNumeric(code) {\n\treturn isNumber(code) || isAlpha(code);\n}\n\nfunction isWhiteSpace(code) {\n\treturn code === 32   /* space */\n\t\t|| code === 9    /* tab */\n\t\t|| code === 160; /* non-breaking space */\n}\n\n/**\n * Check if given character code is a space\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isSpace(code) {\n\treturn isWhiteSpace(code)\n\t\t|| code === 10  /* LF */\n\t\t|| code === 13; /* CR */\n}\n\nconst defaultOptions$1 = {\n\tescape: 92,   // \\ character\n\tthrows: false\n};\n\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param  {StreamReader} stream\n * @param  {Number} open      Character code of pair openinig\n * @param  {Number} close     Character code of pair closing\n * @param  {Object} [options]\n * @return {Boolean}       Returns `true` if chacarter pair was successfully\n *                         consumed, it’s content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n\toptions = options ? Object.assign({}, defaultOptions$1, options) : defaultOptions$1;\n\tconst start = stream.pos;\n\n\tif (stream.eat(open)) {\n\t\tlet stack = 1, ch;\n\n\t\twhile (!stream.eof()) {\n\t\t\tif (eatQuoted(stream, options)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tch = stream.next();\n\t\t\tif (ch === open) {\n\t\t\t\tstack++;\n\t\t\t} else if (ch === close) {\n\t\t\t\tstack--;\n\t\t\t\tif (!stack) {\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (ch === options.escape) {\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then paired character can’t be consumed\n\t\tstream.pos = start;\n\n\t\tif (options.throws) {\n\t\t\tthrow stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport { eatQuoted, isQuote, isAlpha, isNumber, isAlphaNumeric, isSpace, isWhiteSpace, eatPair };\n","import Node from '@emmetio/node';\nimport StreamReader from '@emmetio/stream-reader';\nimport { eatPair, eatQuoted, isAlphaNumeric, isNumber, isQuote, isSpace, isWhiteSpace } from '@emmetio/stream-reader-utils';\n\nconst ASTERISK = 42; // *\n\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n * @param  {StringReader} stream\n * @return {Object}\n */\nvar consumeRepeat = function(stream) {\n\tif (stream.eat(ASTERISK)) {\n\t\tstream.start = stream.pos;\n\n\t\t// XXX think about extending repeat syntax with through numbering\n\t\treturn { count: stream.eatWhile(isNumber) ? +stream.current() : null };\n\t}\n};\n\nconst opt = { throws: true };\n\n/**\n * Consumes quoted literal from current stream position and returns it’s inner,\n * unquoted, value\n * @param  {StringReader} stream\n * @return {String} Returns `null` if unable to consume quoted value from current\n * position\n */\nvar consumeQuoted = function(stream) {\n\tif (eatQuoted(stream, opt)) {\n\t\treturn stream.current().slice(1, -1);\n\t}\n};\n\nconst LCURLY = 123; // {\nconst RCURLY = 125; // }\n\nconst opt$1 = { throws: true };\n\n/**\n * Consumes text node, e.g. contents of `{...}` and returns its inner value\n * @param  {StringReader} stream\n * @return {String} Consumed text content or `null` otherwise\n */\nvar consumeTextNode = function(stream) {\n\treturn eatPair(stream, LCURLY, RCURLY, opt$1)\n\t\t? stream.current().slice(1, -1)\n\t\t: null;\n};\n\nconst EXCL       = 33; // .\nconst DOT$1        = 46; // .\nconst EQUALS     = 61; // =\nconst ATTR_OPEN  = 91; // [\nconst ATTR_CLOSE = 93; // ]\n\nconst reAttributeName = /^\\!?[\\w\\-:\\$@]+\\.?$/;\n\n/**\n * Consumes attributes defined in square braces from given stream.\n * Example:\n * [attr col=3 title=\"Quoted string\" selected. support={react}]\n * @param {StringReader} stream\n * @returns {Array} Array of consumed attributes\n */\nvar consumeAttributes = function(stream) {\n\tif (!stream.eat(ATTR_OPEN)) {\n\t\treturn null;\n\t}\n\n\tconst result = [];\n\tlet token, attr;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isWhiteSpace);\n\n\t\tif (stream.eat(ATTR_CLOSE)) {\n\t\t\treturn result; // End of attribute set\n\t\t} else if ((token = consumeQuoted(stream)) != null) {\n\t\t\t// Consumed quoted value: anonymous attribute\n\t\t\tresult.push({\n\t\t\t\tname: null,\n\t\t\t\tvalue: token\n\t\t\t});\n\t\t} else if (eatUnquoted(stream)) {\n\t\t\t// Consumed next word: could be either attribute name or unquoted default value\n\t\t\ttoken = stream.current();\n\t\t\tif (!reAttributeName.test(token)) {\n\t\t\t\t// anonymous attribute\n\t\t\t\tresult.push({ name: null, value: token });\n\t\t\t} else {\n\t\t\t\t// Looks like a regular attribute\n\t\t\t\tattr = parseAttributeName(token);\n\t\t\t\tresult.push(attr);\n\n\t\t\t\tif (stream.eat(EQUALS)) {\n\t\t\t\t\t// Explicitly defined value. Could be a word, a quoted string\n\t\t\t\t\t// or React-like expression\n\t\t\t\t\tif ((token = consumeQuoted(stream)) != null) {\n\t\t\t\t\t\tattr.value = token;\n\t\t\t\t\t} else if ((token = consumeTextNode(stream)) != null) {\n\t\t\t\t\t\tattr.value = token;\n\t\t\t\t\t\tattr.options = {\n\t\t\t\t\t\t\tbefore: '{',\n\t\t\t\t\t\t\tafter: '}'\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (eatUnquoted(stream)) {\n\t\t\t\t\t\tattr.value = stream.current();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow stream.error('Expected attribute name');\n\t\t}\n\t}\n\n\tthrow stream.error('Expected closing \"]\" brace');\n};\n\nfunction parseAttributeName(name) {\n\tconst options = {};\n\n\t// If a first character in attribute name is `!` — it’s an implied\n\t// default attribute\n\tif (name.charCodeAt(0) === EXCL) {\n\t\tname = name.slice(1);\n\t\toptions.implied = true;\n\t}\n\n\t// Check for last character: if it’s a `.`, user wants boolean attribute\n\tif (name.charCodeAt(name.length - 1) === DOT$1) {\n\t\tname = name.slice(0, name.length - 1);\n\t\toptions.boolean = true;\n\t}\n\n\tconst attr = { name };\n\tif (Object.keys(options).length) {\n\t\tattr.options = options;\n\t}\n\n\treturn attr;\n}\n\n/**\n * Eats token that can be an unquoted value from given stream\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatUnquoted(stream) {\n\tconst start = stream.pos;\n\tif (stream.eatWhile(isUnquoted)) {\n\t\tstream.start = start;\n\t\treturn true;\n\t}\n}\n\nfunction isUnquoted(code) {\n\treturn !isSpace(code) && !isQuote(code)\n\t\t&& code !== ATTR_OPEN && code !== ATTR_CLOSE && code !== EQUALS;\n}\n\nconst HASH    = 35; // #\nconst DOT     = 46; // .\nconst SLASH   = 47; // /\n\n/**\n * Consumes a single element node from current abbreviation stream\n * @param  {StringReader} stream\n * @return {Node}\n */\nvar consumeElement = function(stream) {\n\t// consume element name, if provided\n\tconst start = stream.pos;\n\tconst node = new Node(eatName(stream));\n\tlet next;\n\n\twhile (!stream.eof()) {\n\t\tif (stream.eat(DOT)) {\n\t\t\tnode.addClass(eatName(stream));\n\t\t} else if (stream.eat(HASH)) {\n\t\t\tnode.setAttribute('id', eatName(stream));\n\t\t} else if (stream.eat(SLASH)) {\n\t\t\t// A self-closing indicator must be at the end of non-grouping node\n\t\t\tif (node.isGroup) {\n\t\t\t\tstream.backUp(1);\n\t\t\t\tthrow stream.error('Unexpected self-closing indicator');\n\t\t\t}\n\t\t\tnode.selfClosing = true;\n\t\t\tif (next = consumeRepeat(stream)) {\n\t\t\t\tnode.repeat = next;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (next = consumeAttributes(stream)) {\n\t\t\tfor (let i = 0, il = next.length; i < il; i++) {\n\t\t\t\tnode.setAttribute(next[i]);\n\t\t\t}\n\t\t} else if ((next = consumeTextNode(stream)) !== null) {\n\t\t\tnode.value = next;\n\t\t} else if (next = consumeRepeat(stream)) {\n\t\t\tnode.repeat = next;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === stream.pos) {\n\t\tthrow stream.error(`Unable to consume abbreviation node, unexpected ${stream.peek()}`);\n\t}\n\n\treturn node;\n};\n\nfunction eatName(stream) {\n\tstream.start = stream.pos;\n\tstream.eatWhile(isName);\n\treturn stream.current();\n}\n\nfunction isName(code) {\n\treturn isAlphaNumeric(code)\n\t\t|| code === 45 /* - */\n\t\t|| code === 58 /* : */\n\t\t|| code === 36 /* $ */\n\t\t|| code === 64 /* @ */\n\t\t|| code === 33 /* ! */\n\t\t|| code === 95 /* _ */\n\t\t|| code === 37 /* % */;\n}\n\nconst GROUP_START = 40; // (\nconst GROUP_END   = 41; // )\nconst OP_SIBLING  = 43; // +\nconst OP_CHILD    = 62; // >\nconst OP_CLIMB    = 94; // ^\n\n/**\n * Parses given string into a node tree\n * @param  {String} str Abbreviation to parse\n * @return {Node}\n */\nfunction parse(str) {\n\tconst stream = new StreamReader(str.trim());\n\tconst root = new Node();\n\tlet ctx = root, groupStack = [], ch;\n\n\twhile (!stream.eof()) {\n\t\tch = stream.peek();\n\n\t\tif (ch === GROUP_START) { // start of group\n\t\t\t// The grouping node should be detached to properly handle\n\t\t\t// out-of-bounds `^` operator. Node will be attached right on group end\n\t\t\tconst node = new Node();\n\t\t\tconst groupCtx = groupStack.length ? last(groupStack)[0] : ctx;\n\t\t\tgroupStack.push([node, groupCtx, stream.pos]);\n\t\t\tctx = node;\n\t\t\tstream.next();\n\t\t\tcontinue;\n\t\t} else if (ch === GROUP_END) { // end of group\n\t\t\tconst lastGroup = groupStack.pop();\n\t\t\tif (!lastGroup) {\n\t\t\t\tthrow stream.error('Unexpected \")\" group end');\n\t\t\t}\n\n\t\t\tconst node = lastGroup[0];\n\t\t\tctx = lastGroup[1];\n\t\t\tstream.next();\n\n\t\t\t// a group can have a repeater\n\t\t\tif (node.repeat = consumeRepeat(stream)) {\n\t\t\t\tctx.appendChild(node);\n\t\t\t} else {\n\t\t\t\t// move all children of group into parent node\n\t\t\t\twhile (node.firstChild) {\n\t\t\t\t\tctx.appendChild(node.firstChild);\n\t\t\t\t}\n\t\t\t\t// for convenience, groups can be joined with optional `+` operator\n\t\t\t\tstream.eat(OP_SIBLING);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst node = consumeElement(stream);\n\t\tctx.appendChild(node);\n\n\t\tif (stream.eof()) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (stream.peek()) {\n\t\t\tcase OP_SIBLING:\n\t\t\t\tstream.next();\n\t\t\t\tcontinue;\n\n\t\t\tcase OP_CHILD:\n\t\t\t\tstream.next();\n\t\t\t\tctx = node;\n\t\t\t\tcontinue;\n\n\t\t\tcase OP_CLIMB:\n\t\t\t\t// it’s perfectly valid to have multiple `^` operators\n\t\t\t\twhile (stream.eat(OP_CLIMB)) {\n\t\t\t\t\tctx = ctx.parent || ctx;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (groupStack.length) {\n\t\tstream.pos = groupStack.pop()[2];\n\t\tthrow stream.error('Expected group close');\n\t}\n\n\treturn root;\n}\n\nfunction last(arr) {\n\treturn arr[arr.length - 1];\n}\n\n/**\n * Parses given abbreviation and un-rolls it into a full tree: recursively\n * replaces repeated elements with actual nodes\n * @param  {String} abbr\n * @return {Node}\n */\nvar index = function(abbr) {\n\tconst tree = parse(abbr);\n\ttree.walk(unroll);\n\treturn tree;\n};\n\nfunction unroll(node) {\n\tif (!node.repeat || !node.repeat.count) {\n\t\treturn;\n\t}\n\n\tfor (let i = 1; i < node.repeat.count; i++) {\n\t\tconst clone = node.clone(true);\n\t\tclone.repeat.value = i;\n\t\tclone.walk(unroll);\n\t\tnode.parent.insertBefore(clone, node);\n\t}\n\n\tnode.repeat.value = node.repeat.count;\n}\n\nexport default index;\n","import parse from '@emmetio/abbreviation';\n\n/**\n * For every node in given `tree`, finds matching snippet from `registry` and\n * resolves it into a parsed abbreviation. Resolved node is then updated or\n * replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attribues and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n *\n * @param  {Node} tree                 Parsed Emmet abbreviation\n * @param  {SnippetsRegistry} registry Registry with all available snippets\n * @return {Node} Updated tree\n */\n\nvar index = function(tree, registry) {\n    tree.walk(node => resolveNode(node, registry));\n    return tree;\n};\n\nfunction resolveNode(node, registry) {\n    const stack = new Set();\n    const resolve = node => {\n        const snippet = registry.resolve(node.name);\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.has(snippet)) {\n            return;\n        }\n\n        // In case if matched snippet is a function, pass control into it\n        if (typeof snippet.value === 'function') {\n            return snippet.value(node, registry, resolve);\n        }\n\n        const tree = parse(snippet.value);\n\n        stack.add(snippet);\n        tree.walk(resolve);\n        stack.delete(snippet);\n\n        // move current node contents into new tree\n        const childTarget = findDeepestNode(tree);\n        merge(childTarget, node);\n\n        while (tree.firstChild) {\n            node.parent.insertBefore(tree.firstChild, node);\n        }\n\n        childTarget.parent.insertBefore(node, childTarget);\n        childTarget.remove();\n    };\n\n    resolve(node);\n}\n\n/**\n * Adds data from first node into second node and returns it\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction merge(from, to) {\n    to.name = from.name;\n\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n\n    if (from.value != null) {\n        to.value = from.value;\n    }\n\n    if (from.repeat) {\n        to.repeat = Object.assign({}, from.repeat);\n    }\n\n    return mergeAttributes(from, to);\n}\n\n/**\n * Transfer attributes from first element to second one and preserve first\n * element’s attributes order\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction mergeAttributes(from, to) {\n    mergeClassNames(from, to);\n\n    // It’s important to preserve attributes order: ones in `from` have higher\n    // pripority than in `to`. Collect attributes in map in order they should\n    // appear in `to`\n    const attrMap = new Map();\n\n    let attrs = from.attributes;\n    for (let i = 0; i < attrs.length; i++) {\n        attrMap.set(attrs[i].name, attrs[i].clone());\n    }\n\n    attrs = to.attributes.slice();\n    for (let i = 0, attr, a; i < attrs.length; i++) {\n        attr = attrs[i];\n        if (attrMap.has(attr.name)) {\n            a = attrMap.get(attr.name);\n            a.value = attr.value;\n\n            // If user explicitly wrote attribute in abbreviation, it’s no longer\n            // implied and should be outputted even if value is empty\n            if (a.options.implied) {\n                a.options.implied = false;\n            }\n        } else {\n            attrMap.set(attr.name, attr);\n        }\n\n        to.removeAttribute(attr);\n    }\n\n    const newAttrs = Array.from(attrMap.values());\n    for (let i = 0; i < newAttrs.length; i++) {\n        to.setAttribute(newAttrs[i]);\n    }\n\n    return to;\n}\n\n/**\n * Adds class names from first node to second one\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction mergeClassNames(from, to) {\n    const classNames = from.classList;\n    for (let i = 0; i < classNames.length; i++) {\n        to.addClass(classNames[i]);\n    }\n\n    return to;\n}\n\n/**\n * Finds node which is the deepest for in current node or node iteself.\n * @param  {Node} node\n * @return {Node}\n */\nfunction findDeepestNode(node) {\n\twhile (node.children.length) {\n\t\tnode = node.children[node.children.length - 1];\n\t}\n\n\treturn node;\n}\n\nexport default index;\n","const inlineElements = new Set('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(','));\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\n\n/**\n * Returns best child node name for given parent node name\n * @param  {String} parentName Name of parent node\n * @return {String}\n */\nfunction resolveImplicitName(parentName) {\n    parentName = (parentName || '').toLowerCase();\n    return elementMap[parentName]\n        || (inlineElements.has(parentName) ? 'span' : 'div');\n}\n\nexport default resolveImplicitName;\n","import resolveImplicitTag from '@emmetio/implicit-tag';\n\n/**\n * Adds missing tag names for given tree depending on node’s parent name\n */\nvar implicitTags = function(tree) {\n    tree.walk(node => {\n        // resolve only nameless nodes without content\n        if (node.name == null && node.attributes.length) {\n            node.name = resolveImplicitTag(node.parent.name);\n        }\n    });\n    return tree;\n};\n\n/**\n * Locates all occurances of given `token` which are not escaped (e.g. are not\n * preceded with `\\`) given in `str`\n * @param  {String} str\n * @return {Array}  Array of token ranges\n */\nfunction findUnescapedTokens(str, token) {\n    const result = new Set();\n    const tlen = token.length;\n\n    // 1. Find all occurances of tokens\n    let pos = 0;\n    while ((pos = str.indexOf(token, pos)) !== -1) {\n        result.add(pos);\n        pos += tlen;\n    }\n\n    if (result.size) {\n        // 2. Remove ones that escaped\n        let pos = 0;\n        const len = str.length;\n\n        while (pos < len) {\n            if (str[pos++] === '\\\\') {\n                result.delete(pos++);\n            }\n        }\n    }\n\n    return Array.from(result).map(ix => range(ix, tlen));\n}\n\n/**\n * Replaces `ranges`, generated by `range()` function, with given `value` in `str`\n * @param  {String} str    Where to replace ranges\n * @param  {Array} ranges Ranes, created by `range()` function\n * @param  {String|Function} value  Replacement value. If it’s a function, it\n * will take a range value as argument and should return a new string\n * @return {String}\n */\nfunction replaceRanges(str, ranges, value) {\n\t// should walk from the end of array to keep ranges valid after replacement\n\tfor (let i = ranges.length - 1; i >= 0; i--) {\n\t\tconst r = ranges[i];\n\n\t\tstr = str.substring(0, r[0])\n\t\t\t+ (typeof value === 'function' ? value(str.substr(r[0], r[1])) : value)\n\t\t\t+ str.substring(r[0] + r[1]);\n\t}\n\n\treturn str;\n}\n\nfunction range(start, length) {\n    return [start, length];\n}\n\nconst numberingToken = '$';\n\n/**\n * Numbering of expanded abbreviation: finds all nodes with `$` in value\n * or attributes and replaces its occurances with repeater value\n */\nvar applyNumbering = function(tree) {\n    tree.walk(applyNumbering$1);\n    return tree;\n};\n\n/**\n * Applies numbering for given node: replaces occurances of numbering token\n * in node’s name, content and attributes\n * @param  {Node} node\n * @return {Node}\n */\nfunction applyNumbering$1(node) {\n    const repeater = findRepeater(node);\n\n    if (repeater && repeater.value != null) {\n        // NB replace numbering in nodes with explicit repeater only:\n        // it solves issues with abbreviations like `xsl:if[test=$foo]` where\n        // `$foo` is preferred output\n        const value = repeater.value;\n\n        node.name = replaceNumbering(node.name, value);\n        node.value = replaceNumbering(node.value, value);\n        node.attributes.forEach(attr => {\n            const copy = node.getAttribute(attr.name).clone();\n            copy.name = replaceNumbering(attr.name, value);\n            copy.value = replaceNumbering(attr.value, value);\n            node.replaceAttribute(attr.name, copy);\n        });\n    }\n\n    return node;\n}\n\n/**\n * Returns repeater object for given node\n * @param  {Node} node\n * @return {Object}\n */\nfunction findRepeater(node) {\n    while (node) {\n        if (node.repeat) {\n            return node.repeat;\n        }\n\n        node = node.parent;\n    }\n}\n\n/**\n * Replaces numbering in given string\n * @param  {String} str\n * @param  {Number} value\n * @return {String}\n */\nfunction replaceNumbering(str, value) {\n    // replace numbering in strings only: skip explicit wrappers that could\n    // contain unescaped numbering tokens\n    if (typeof str === 'string') {\n        const ranges = getNumberingRanges(str);\n        return replaceNumberingRanges(str, ranges, value);\n    }\n\n    return str;\n}\n\n/**\n * Returns numbering ranges, e.g. ranges of `$` occurances, in given string.\n * Multiple adjacent ranges are combined\n * @param  {String} str\n * @return {Array}\n */\nfunction getNumberingRanges(str) {\n    return findUnescapedTokens(str || '', numberingToken)\n    .reduce((out, range$$1) => {\n        // skip ranges that actually belongs to output placeholder or tabstops\n        if (!/[#{]/.test(str[range$$1[0] + 1] || '')) {\n            const lastRange = out[out.length - 1];\n            if (lastRange && lastRange[0] + lastRange[1] === range$$1[0]) {\n                lastRange[1] += range$$1[1];\n            } else {\n                out.push(range$$1);\n            }\n        }\n\n        return out;\n    }, []);\n}\n\n/**\n * @param  {String} str\n * @param  {Array} ranges\n * @param  {Number} value\n * @return {String}\n */\nfunction replaceNumberingRanges(str, ranges, value) {\n    const replaced = replaceRanges(str, ranges, token => {\n        let _value = String(value);\n        // pad values for multiple numbering tokens, e.g. 3 for $$$ becomes 003\n        while (_value.length < token.length) {\n            _value = '0' + _value;\n        }\n        return _value;\n    });\n\n    // unescape screened numbering tokens\n    return unescapeString(replaced);\n}\n\n/**\n * Unescapes characters, screened with `\\`, in given string\n * @param  {String} str\n * @return {String}\n */\nfunction unescapeString(str) {\n    let i = 0, result = '';\n    const len = str.length;\n\n    while (i < len) {\n        const ch = str[i++];\n        result += (ch === '\\\\') ? (str[i++] || '') : ch;\n    }\n\n    return result;\n}\n\n/** Placeholder for inserted content */\nconst placeholder = '$#';\n\n/** Placeholder for caret */\nconst caret = '|';\n\nconst reUrl = /^((?:https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/;\nconst reEmail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/;\nconst reProto = /^([a-z]+:)?\\/\\//i;\n\n/**\n * Inserts content into node with implicit repeat count: this node is then\n * duplicated for each content item and content itself is inserted either into\n * deepest child or instead of a special token.\n *\n * This method uses two distinct steps: `prepare()` and `insert()` since most\n * likely these steps will be used separately to properly insert content\n * with unescaped `$` numbering markers.\n *\n * @param {Node} tree Parsed abbreviation\n * @param {String[]} content Array of content items to insert\n * @return {Node}\n */\n/**\n * Finds nodes with implicit repeat and creates `amount` copies of it in tree\n * @param  {Node} tree\n * @param  {Number} amount\n * @return {Node}\n */\nfunction prepare(tree, amount) {\n    amount = amount || 1;\n    tree.walk(node => {\n        if (node.repeat && node.repeat.count === null) {\n            for (let i = 0; i < amount; i++) {\n                const clone = node.clone(true);\n                clone.repeat.implicit = true;\n                clone.repeat.count = amount;\n                clone.repeat.value = i + 1;\n                clone.repeat.index = i;\n                node.parent.insertBefore(clone, node);\n            }\n\n            node.remove();\n        }\n    });\n\n    return tree;\n}\n\n/**\n * Inserts content into implicitly repeated nodes, created by `prepare()` method\n * @param  {Node} tree\n * @param  {String[]} content\n * @return {Node}\n */\nfunction insert(tree, content) {\n    if (Array.isArray(content) && content.length) {\n        let updated = false;\n        tree.walk(node => {\n            if (node.repeat && node.repeat.implicit) {\n                updated = true;\n                insertContent(node, content[node.repeat.index]);\n            }\n        });\n\n        if (!updated) {\n            // no node with implicit repeat was found, insert content as\n            // deepest child\n            setNodeContent(findDeepestNode(tree), content.join('\\n'));\n        }\n    }\n\n    return tree;\n}\n\n/**\n * Inserts `content` into given `node`: either replaces output placeholders\n * or inserts it into deepest child node\n * @param  {Node} node\n * @param  {String} content\n * @return {Node}\n */\nfunction insertContent(node, content) {\n\tlet inserted = insertContentIntoPlaceholder(node, content);\n\tnode.walk(child => inserted |= insertContentIntoPlaceholder(child, content));\n\n\tif (!inserted) {\n\t\t// no placeholders were found in node, insert content into deepest child\n\t\tsetNodeContent(findDeepestNode(node), content);\n\t}\n\n\treturn node;\n}\n\n/**\n * Inserts given `content` into placeholders for given `node`. Placeholders\n * might be available in attribute values and node content\n * @param  {Node} node\n * @param  {String} content\n * @return {Boolean} Returns `true` if placeholders were found and replaced in node\n */\nfunction insertContentIntoPlaceholder(node, content) {\n\tconst state = {replaced: false};\n\n\tnode.value = replacePlaceholder(node.value, content, state);\n\tnode.attributes.forEach(attr => {\n\t\tif (attr.value) {\n\t\t\tnode.setAttribute(attr.name, replacePlaceholder(attr.value, content, state));\n\t\t}\n\t});\n\n\treturn state.replaced;\n}\n\n/**\n * Replaces all placeholder occurances in given `str` with `value`\n * @param  {String} str\n * @param  {String} value\n * @param  {Object} [_state] If provided, set `replaced` property of given\n * object to `true` if placeholder was found and replaced\n * @return {String}\n */\nfunction replacePlaceholder(str, value, _state) {\n\tif (typeof str === 'string') {\n\t\tconst ranges = findUnescapedTokens(str, placeholder);\n\t\tif (ranges.length) {\n\t\t\tif (_state) {\n\t\t\t\t_state.replaced = true;\n\t\t\t}\n\n\t\t\tstr = replaceRanges(str, ranges, value);\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * Finds node which is the deepest for in current node or node iteself.\n * @param  {Node} node\n * @return {Node}\n */\nfunction findDeepestNode(node) {\n\twhile (node.children.length) {\n\t\tnode = node.children[node.children.length - 1];\n\t}\n\n\treturn node;\n}\n\n/**\n * Updates content of given node\n * @param {Node} node\n * @param {String} content\n */\nfunction setNodeContent(node, content) {\n\t// find caret position and replace it with content, if possible\n\tif (node.value) {\n\t\tconst ranges = findUnescapedTokens(node.value, caret);\n\t\tif (ranges.length) {\n\t\t\tnode.value = replaceRanges(node.value, ranges, content);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (node.name.toLowerCase('a') || node.hasAttribute('href')) {\n\t\t// special case: inserting content into `<a>` tag\n\t\tif (reUrl.test(content)) {\n\t\t\tnode.setAttribute('href', (reProto.test(content) ? '' : 'http://') + content);\n\t\t} else if (reEmail.test(content)) {\n\t\t\tnode.setAttribute('href', 'mailto:' + content);\n\t\t}\n\t}\n\n\tnode.value = content;\n}\n\nconst defaultOptions = {\n\telement: '__',\n\tmodifier: '_'\n};\n\nconst reElement  = /^(-+)([a-z0-9]+)/i;\nconst reModifier = /^(_+)([a-z0-9]+)/i;\nconst blockCandidates1 = className => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = className => /^[a-z]/i.test(className);\n\n/**\n * BEM transformer: updates class names written as `-element` and\n * `_modifier` into full class names as described in BEM specs. Also adds missing\n * class names: fir example, if node contains `.block_modifier` class, ensures\n * that element contains `.block` class as well\n */\nvar bem = function(tree, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\n\ttree.walk(node => expandClassNames(node, options));\n\n\tconst lookup = createBlockLookup(tree);\n    tree.walk(node => expandShortNotation(node, lookup, options));\n\n\treturn tree;\n};\n\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n * @param  {Node} node\n * @param  {Object} options\n * @return {Set}\n */\nfunction expandClassNames(node, options) {\n\tconst classNames = node.classList.reduce((out, cl) => {\n\t\t// remove all modifiers from class name to get a base element name\n\t\tconst ix = cl.indexOf(options.modifier);\n\t\tif (ix !== -1) {\n\t\t\tout.add(cl.slice(0, ix));\n\t\t}\n\n\t\treturn out.add(cl);\n\t}, new Set());\n\n\tif (classNames.size) {\n\t\tnode.setAttribute('class', Array.from(classNames).join(' '));\n\t}\n}\n\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n * @param  {Node} node      Parsed Emmet abbreviation node\n * @param  {Map} lookup     BEM block name lookup\n * @param  {Object} options\n */\nfunction expandShortNotation(node, lookup, options) {\n\tconst classNames = node.classList.reduce((out, cl) => {\n\t\tlet prefix, m;\n\t\tconst originalClass = cl;\n\n\t\t// parse element definition (could be only one)\n\t\tif (m = cl.match(reElement)) {\n\t\t\tprefix = getBlockName(node, lookup, m[1]) + options.element + m[2];\n\t\t\tout.add(prefix);\n\t\t\tcl = cl.slice(m[0].length);\n\t\t}\n\n\t\t// parse modifiers definitions (may contain multiple)\n\t\twhile (m = cl.match(reModifier)) {\n\t\t\tif (!prefix) {\n\t\t\t\tprefix = getBlockName(node, lookup, m[1]);\n\t\t\t\tout.add(prefix);\n\t\t\t}\n\n\t\t\tout.add(`${prefix}${options.modifier}${m[2]}`);\n\t\t\tcl = cl.slice(m[0].length);\n\t\t}\n\n\t\tif (cl === originalClass) {\n\t\t\t// class name wasn’t modified: it’s not a BEM-specific class,\n\t\t\t// add it as-is into output\n\t\t\tout.add(originalClass);\n\t\t}\n\n\t\treturn out;\n\t}, new Set());\n\n\tnode.setAttribute('class', Array.from(classNames).join(' '));\n}\n\n/**\n * Creates block name lookup for each node in given tree, e.g. finds block\n * name explicitly for each node\n * @param  {Node} tree\n * @return {Map}\n */\nfunction createBlockLookup(tree) {\n\tconst lookup = new Map();\n\n\ttree.walk(node => {\n\t\tconst classNames = node.classList;\n\t\tif (classNames.length) {\n\t\t\t// guess best block name from class or use parent’s block name\n\t\t\tlookup.set(node,\n\t\t\t\tfind(classNames, blockCandidates1)\n\t\t\t\t|| find(classNames, blockCandidates2)\n\t\t\t\t|| lookup.get(node.parent)\n\t\t\t);\n\t\t}\n\t});\n\n\treturn lookup;\n}\n\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n * @param  {Node} node\n * @param  {Map} lookup\n * @param  {String} prefix\n * @return {String}\n */\nfunction getBlockName(node, lookup, prefix) {\n\tlet depth = prefix.length > 1 ? prefix.length : 0;\n\twhile (node.parent && depth--) {\n\t\tnode = node.parent;\n\t}\n\n\treturn lookup.get(node);\n}\n\nfunction find(arr, filter) {\n\treturn arr.filter(filter)[0];\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nvar jsx = function(tree) {\n\ttree.walk(node => {\n\t\treplace(node, 'class', 'className');\n\t\treplace(node, 'for', 'htmlFor');\n\t});\n\treturn tree;\n};\n\nfunction replace(node, oldName, newName) {\n\tlet attr = node.getAttribute(oldName);\n\tif (attr) {\n\t\tattr.name = newName;\n\t}\n}\n\nconst reSupporterNames = /^xsl:(variable|with\\-param)$/i;\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nvar xsl = function(tree) {\n\ttree.walk(node => {\n\t\tif (reSupporterNames.test(node.name || '') && (node.children.length || node.value)) {\n\t\t\tnode.removeAttribute('select');\n\t\t}\n\t});\n\treturn tree;\n};\n\nconst supportedAddons = { bem, jsx, xsl };\n\n/**\n * Runs additional transforms on given tree.\n * These transforms may introduce side-effects and unexpected result\n * so they are not applied by default, authors must specify which addons\n * in `addons` argument as `{addonName: addonOptions}`\n * @param {Node} tree Parsed Emmet abbreviation\n * @param {Object} addons Add-ons to apply and their options\n */\nvar addons = function(tree, addons) {\n    Object.keys(addons || {}).forEach(key => {\n        if (key in supportedAddons) {\n            const addonOpt = typeof addons[key] === 'object' ? addons[key] : null;\n            tree = tree.use(supportedAddons[key], addonOpt);\n        }\n    });\n\n    return tree;\n};\n\n/**\n * Applies basic HTML-specific transformations for given parsed abbreviation:\n * – resolve implied tag names\n * – insert repeated content\n * – resolve node numbering\n */\nvar index = function(tree, content, appliedAddons) {\n    if (typeof content === 'string') {\n        content = [content];\n    } else if (content && typeof content === 'object' && !Array.isArray(content)) {\n        appliedAddons = content;\n        content = null;\n    }\n\n    return tree\n    .use(implicitTags)\n    .use(prepare, Array.isArray(content) ? content.length : null)\n    .use(applyNumbering)\n    .use(insert, content)\n    .use(addons, appliedAddons);\n};\n\nexport default index;\n","/**\n * Replaces all unescaped ${variable} occurances in given parsed abbreviation\n * `tree` with values provided in `variables` hash. Precede `$` with `\\` to\n * escape it and skip replacement\n * @param {Node} tree Parsed abbreviation tree\n * @param {Object} variables Variables values\n * @return {Node}\n */\nfunction replaceVariables(tree, variables) {\n\tvariables = variables || {};\n    tree.walk(node => replaceInNode(node, variables));\n    return tree;\n}\n\nfunction replaceInNode(node, variables) {\n    // Replace variables in attributes.\n    const attrs = node.attributes;\n\n    for (let i = 0, il = attrs.length; i < il; i++) {\n        const attr = attrs[i];\n        if (typeof attr.value === 'string') {\n            node.setAttribute(attr.name, replaceInString(attr.value, variables));\n        }\n    }\n\n    if (node.value != null) {\n        node.value = replaceInString(node.value, variables);\n    }\n\n    return node;\n}\n\n/**\n * Replaces all unescaped `${variable}` occurances in given string with values\n * from `variables` object\n * @param  {String} string\n * @param  {Object} variables\n * @return {String}\n */\nfunction replaceInString(string, variables) {\n    const model = createModel(string);\n    let offset = 0;\n    let output = '';\n\n    for (let i = 0, il = model.variables.length; i < il; i++) {\n        const v = model.variables[i];\n        let value = v.name in variables ? variables[v.name] : v.name;\n        if (typeof value === 'function') {\n            value = value(model.string, v, offset + v.location);\n        }\n\n        output += model.string.slice(offset, v.location) + value;\n        offset = v.location + v.length;\n    }\n\n    return output + model.string.slice(offset);\n}\n\n/**\n * Creates variable model from given string. The model contains a `string` with\n * all escaped variable tokens written without escape symbol and `variables`\n * property with all unescaped variables and their ranges\n * @param  {String} string\n * @return {Object}\n */\nfunction createModel(string) {\n    const reVariable = /\\$\\{([a-z][\\w\\-]*)\\}/ig;\n    const escapeCharCode = 92; // `\\` symbol\n    const variables = [];\n\n    // We have to replace unescaped (e.g. not preceded with `\\`) tokens.\n    // Instead of writing a stream parser, we’ll cut some edges here:\n    // 1. Find all tokens\n    // 2. Walk string char-by-char and resolve only tokens that are not escaped\n    const tokens = new Map();\n    let m;\n    while (m = reVariable.exec(string)) {\n        tokens.set(m.index, m);\n    }\n\n    if (tokens.size) {\n        let start = 0, pos = 0, len = string.length;\n        let output = '';\n        while (pos < len) {\n            if (string.charCodeAt(pos) === escapeCharCode && tokens.has(pos + 1)) {\n                // Found escape symbol that escapes variable: we should\n                // omit this symbol in output string and skip variable\n                const token = tokens.get(pos + 1);\n                output += string.slice(start, pos) + token[0];\n                start = pos = token.index + token[0].length;\n                tokens.delete(pos + 1);\n                continue;\n            }\n\n            pos++;\n        }\n\n        string = output + string.slice(start);\n\n        // Not using `.map()` here to reduce memory allocations\n        const validMatches = Array.from(tokens.values());\n        for (let i = 0, il = validMatches.length; i < il; i++) {\n            const token = validMatches[i];\n            variables.push({\n                name: token[1],\n                location: token.index,\n                length: token[0].length\n            });\n        }\n    }\n\n    return {string, variables};\n}\n\nexport default replaceVariables;\n","import StreamReader from '@emmetio/stream-reader';\nimport { isNumber } from '@emmetio/stream-reader-utils';\n\nconst DOLLAR      = 36;  // $\nconst COLON       = 58;  // :\nconst ESCAPE      = 92;  // \\\nconst OPEN_BRACE  = 123; // {\nconst CLOSE_BRACE = 125; // }\n\n/**\n * Finds fields in given string and returns object with field-less string\n * and array of fileds found\n * @param  {String} string\n * @return {Object}\n */\nfunction parse(string) {\n\tconst stream = new StreamReader(string);\n\tconst fields = [];\n\tlet cleanString = '', offset = 0, pos = 0;\n\tlet code, field;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\t\tpos = stream.pos;\n\n\t\tif (code === ESCAPE) {\n\t\t\tstream.next();\n\t\t\tstream.next();\n\t\t} else if (field = consumeField(stream, cleanString.length + pos - offset)) {\n\t\t\tfields.push(field);\n\t\t\tcleanString += stream.string.slice(offset, pos) + field.placeholder;\n\t\t\toffset = stream.pos;\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn new FieldString(cleanString + stream.string.slice(offset), fields);\n}\n\n/**\n * Marks given `string` with `fields`: wraps each field range with\n * `${index:placeholder}` (by default) or any other token produced by `token`\n * function, if provided\n * @param  {String} string String to mark\n * @param  {Array} fields Array of field descriptor. A field descriptor is a\n * `{index, location, length}` array. It is important that fields in array\n * must be ordered by their location in string: some fields my refer the same\n * location so they must appear in order that user expects.\n * @param  {Function} [token] Function that generates field token. This function\n * received two arguments: `index` and `placeholder` and should return string\n * @return {String}  String with marked fields\n */\nfunction mark(string, fields, token) {\n\ttoken = token || createToken;\n\n\t// order fields by their location and appearence\n\t// NB field ranges should not overlap! (not supported yet)\n\tconst ordered = fields\n\t.map((field, order) => ({order, field, end: field.location + field.length}))\n\t.sort((a, b) => (a.end - b.end) || (a.order - b.order));\n\n\t// mark ranges in string\n\tlet offset = 0;\n\tconst result = ordered.map(item => {\n\t\tconst placeholder = string.substr(item.field.location, item.field.length);\n\t\tconst prefix = string.slice(offset, item.field.location);\n\t\toffset = item.end;\n\t\treturn prefix + token(item.field.index, placeholder);\n\t});\n\n\treturn result.join('') + string.slice(offset);\n}\n\n/**\n * Creates field token for string\n * @param  {Number} index       Field index\n * @param  {String} placeholder Field placeholder, could be empty string\n * @return {String}\n */\nfunction createToken(index, placeholder) {\n\treturn placeholder ? `\\${${index}:${placeholder}}` : `\\${${index}}`;\n}\n\n/**\n * Consumes field from current stream position: it can be an `$index` or\n * or `${index}` or `${index:placeholder}`\n * @param  {StreamReader} stream\n * @param  {Number}       location Field location in *clean* string\n * @return {Object} Object with `index` and `placeholder` properties if\n * fieald was successfully consumed, `null` otherwise\n */\nfunction consumeField(stream, location) {\n\tconst start = stream.pos;\n\n\tif (stream.eat(DOLLAR)) {\n\t\t// Possible start of field\n\t\tlet index = consumeIndex(stream);\n\t\tlet placeholder = '';\n\n\t\t// consumed $index placeholder\n\t\tif (index != null) {\n\t\t\treturn new Field(index, placeholder, location);\n\t\t}\n\n\t\tif (stream.eat(OPEN_BRACE)) {\n\t\t\tindex = consumeIndex(stream);\n\t\t\tif (index != null) {\n\t\t\t\tif (stream.eat(COLON)) {\n\t\t\t\t\tplaceholder = consumePlaceholder(stream);\n\t\t\t\t}\n\n\t\t\t\tif (stream.eat(CLOSE_BRACE)) {\n\t\t\t\t\treturn new Field(index, placeholder, location);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we reached here then there’s no valid field here, revert\n\t// back to starting position\n\tstream.pos = start;\n}\n\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n * @param  {StreamReader} stream\n * @return {String}\n */\nfunction consumePlaceholder(stream) {\n\tlet code;\n\tconst stack = [];\n\tstream.start = stream.pos;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\n\t\tif (code === OPEN_BRACE) {\n\t\t\tstack.push(stream.pos);\n\t\t} else if (code === CLOSE_BRACE) {\n\t\t\tif (!stack.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstack.pop();\n\t\t}\n\t\tstream.next();\n\t}\n\n\tif (stack.length) {\n\t\tthrow stream.error('Unable to find matching \"}\" for curly brace at ' + stack.pop());\n\t}\n\n\treturn stream.current();\n}\n\n/**\n * Consumes integer from current stream position\n * @param  {StreamReader} stream\n * @return {Number}\n */\nfunction consumeIndex(stream) {\n\tstream.start = stream.pos;\n\tif (stream.eatWhile(isNumber)) {\n\t\treturn Number(stream.current());\n\t}\n}\n\nclass Field {\n\tconstructor(index, placeholder, location) {\n\t\tthis.index = index;\n\t\tthis.placeholder = placeholder;\n\t\tthis.location = location;\n\t\tthis.length = this.placeholder.length;\n\t}\n}\n\nclass FieldString {\n\t/**\n\t * @param {String} string\n\t * @param {Field[]} fields\n\t */\n\tconstructor(string, fields) {\n\t\tthis.string = string;\n\t\tthis.fields = fields;\n\t}\n\n\tmark(token) {\n\t\treturn mark(this.string, this.fields, token);\n\t}\n\n\ttoString() {\n\t\treturn string;\n\t}\n}\n\nexport { mark, createToken };export default parse;\n","import parseFields from '@emmetio/field-parser';\n\nconst defaultFieldsRenderer = text => text;\n\n/**\n * Output node is an object containing generated output for given Emmet\n * abbreviation node. Output node can be passed to various processors that\n * may shape-up final node output. The final output is simply a concatenation\n * of `.open`, `.text` and `.close` properties and its `.before*` and `.after*`\n * satellites\n * @param {Node}     node           Parsed Emmet abbreviation node\n * @param {Function} fieldsRenderer A function for rendering fielded text (text with\n * tabstops) for current node. @see ./render.js for details\n */\nclass OutputNode {\n\tconstructor(node, fieldsRenderer, options) {\n\t\tif (typeof fieldsRenderer === 'object') {\n\t\t\toptions = fieldsRenderer;\n\t\t\tfieldsRenderer = null;\n\t\t}\n\n\t\tthis.node = node;\n\t\tthis._fieldsRenderer = fieldsRenderer || defaultFieldsRenderer;\n\n\t\tthis.open = null;\n\t\tthis.beforeOpen = '';\n\t\tthis.afterOpen = '';\n\n\t\tthis.close = null;\n\t\tthis.beforeClose = '';\n\t\tthis.afterClose = '';\n\n\t\tthis.text = null;\n\t\tthis.beforeText = '';\n\t\tthis.afterText = '';\n\n\t\tthis.indent = '';\n\t\tthis.newline = '';\n\n\t\tif (options) {\n            Object.assign(this, options);\n        }\n\t}\n\n\tclone() {\n\t\treturn new this.constructor(this.node, this);\n\t}\n\n\t/**\n\t * Properly indents given multiline text\n\t * @param {String} text\n\t */\n\tindentText(text) {\n\t\tconst lines = splitByLines(text);\n        if (lines.length === 1) {\n            // no newlines, nothing to indent\n            return text;\n        }\n\n        // No newline and no indent means no formatting at all:\n        // in this case we should replace newlines with spaces\n        const nl = (!this.newline && !this.indent) ? ' ' : this.newline;\n        return lines.map((line, i) => i ? this.indent + line : line).join(nl);\n\t}\n\n\t/**\n\t * Renders given text with fields\n\t * @param {String} text\n\t * @return {String}\n\t */\n\trenderFields(text) {\n\t\treturn this._fieldsRenderer(text);\n\t}\n\n\ttoString(children) {\n\t\tconst open = this._wrap(this.open, this.beforeOpen, this.afterOpen);\n\t\tconst close = this._wrap(this.close, this.beforeClose, this.afterClose);\n\t\tconst text = this._wrap(this.text, this.beforeText, this.afterText);\n\n\t\treturn open + text + (children != null ? children : '') + close;\n\t}\n\n\t_wrap(str, before, after) {\n\t\tbefore = before != null ? before : '';\n\t\tafter = after != null ? after : '';\n\n        // automatically trim whitespace for non-empty wraps\n        if (str != null) {\n            str = before ? str.replace(/^\\s+/, '') : str;\n            str = after ? str.replace(/\\s+$/, '') : str;\n            return before + this.indentText(str) + after;\n        }\n\n        return '';\n\t}\n}\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]}\n */\nfunction splitByLines(text) {\n\treturn (text || '').split(/\\r\\n|\\r|\\n/g);\n}\n\n/**\n * Default output of field (tabstop)\n * @param  {Number} index       Field index\n * @param  {String} placeholder Field placeholder, can be null\n * @return {String}\n */\nconst defaultField = (index, placeholder) => (placeholder || '');\n\n/**\n * Renders given parsed abbreviation `tree` via `formatter` function.\n\n * @param {Node}     tree      Parsed Emmet abbreviation\n * @param {Function} [field]   Optional function to format field/tabstop (@see `defaultField`)\n * @param {Function} formatter Output formatter function. It takes an output node—\n * a special wrapper for parsed node that holds formatting and output properties—\n * and updates its output properties to shape-up node’s output.\n * Function arguments:\n * \t– `outNode`: OutputNode\n * \t– `renderFields`: a helper function that parses fields/tabstops from given\n * \t   text and replaces them with `field` function output.\n * \t   It also takes care about field indicies and ensures that the same indicies\n * \t   from different nodes won’t collide\n */\nfunction render(tree, field, formatter) {\n    if (typeof formatter === 'undefined') {\n        formatter = field;\n        field = null;\n    }\n\n    field = field || defaultField;\n\n    // Each node may contain fields like `${1:placeholder}`.\n\t// Since most modern editors will link all fields with the same\n\t// index, we have to ensure that different nodes has their own indicies.\n\t// We’ll use this `fieldState` object to globally increment field indices\n\t// during output\n\tconst fieldState = { index: 1 };\n\n    const fieldsRenderer = text => text == null\n        ? field(fieldState.index++)\n        : getFieldsModel(text, fieldState).mark(field);\n\n\treturn run(tree.children, formatter, fieldsRenderer);\n}\n\nfunction run(nodes, formatter, fieldsRenderer) {\n\treturn nodes.filter(notGroup).map(node => {\n\t\tconst outNode = formatter(new OutputNode(node, fieldsRenderer));\n\t\treturn outNode ? outNode.toString(run(node.children, formatter, fieldsRenderer)) : '';\n\t}).join('');\n}\n\nfunction notGroup(node) {\n    return !node.isGroup;\n}\n\n/**\n * Returns fields (tab-stops) model with properly updated indices that won’t\n * collide with fields in other nodes of foprmatted tree\n * @param  {String|Object} text Text to get fields model from or model itself\n * @param  {Object} fieldState Abbreviation tree-wide field state reference\n * @return {Object} Field model\n */\nfunction getFieldsModel(text, fieldState) {\n\tconst model = typeof text === 'object' ? text : parseFields(text);\n    let largestIndex = -1;\n\n    model.fields.forEach(field => {\n\t\tfield.index += fieldState.index;\n\t\tif (field.index > largestIndex) {\n\t\t\tlargestIndex = field.index;\n\t\t}\n\t});\n\n\tif (largestIndex !== -1) {\n\t\tfieldState.index = largestIndex + 1;\n\t}\n\n    return model;\n}\n\nexport default render;\n","import parseFields from '@emmetio/field-parser';\nimport render from '@emmetio/output-renderer';\n\nconst TOKEN       = /^(.*?)([A-Z_]+)(.*?)$/;\nconst TOKEN_OPEN  = 91; // [\nconst TOKEN_CLOSE = 93; // ]\n\n/**\n * A basic templating engine.\n * Takes every `[TOKEN]` from given string and replaces it with\n * `TOKEN` value from given `data` attribute. The token itself may contain\n * various characters between `[`, token name and `]`. Contents of `[...]` will\n * be outputted only if `TOKEN` value is not empty. Also, only `TOKEN` name will\n * be replaced with actual value, all other characters will remain as is.\n *\n * Example:\n * ```\n * template('[<NAME>]', {NAME: 'foo'}) -> \"<foo>\"\n * template('[<NAME>]', {}) -> \"\"\n * ```\n */\nfunction template(str, data) {\n\tif (str == null) {\n\t\treturn str;\n\t}\n\n\t// NB since token may contain inner `[` and `]`, we can’t just use regexp\n\t// for replacement, should manually parse string instead\n\tconst stack = [];\n\tconst replacer = (str, left, token, right) =>\n\t\tdata[token] != null ? left + data[token] + right : '';\n\n\tlet output = '';\n\tlet offset = 0, i = 0;\n\tlet code, lastPos;\n\n\twhile (i < str.length) {\n\t\tcode = str.charCodeAt(i);\n\t\tif (code === TOKEN_OPEN) {\n\t\t\tstack.push(i);\n\t\t} else if (code === TOKEN_CLOSE) {\n\t\t\tlastPos = stack.pop();\n\t\t\tif (!stack.length) {\n\t\t\t\toutput += str.slice(offset, lastPos) +\n\t\t\t\t\tstr.slice(lastPos + 1, i).replace(TOKEN, replacer);\n\t\t\t\toffset = i + 1;\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn output + str.slice(offset);\n}\n\n/**\n * Various utility methods used by formatters\n */\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]}\n */\nfunction splitByLines(text) {\n\treturn (text || '').split(/\\r\\n|\\r|\\n/g);\n}\n\n/**\n * Check if given node is a first child in its parent\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isFirstChild(node) {\n\treturn node.parent.firstChild === node;\n}\n\n/**\n * Check if given node is a last child in its parent node\n * @param  {Node}  node\n * @return {Boolean}\n */\n\n\n/**\n * Check if given node is a root node\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isRoot(node) {\n\treturn node && !node.parent;\n}\n\n/**\n * Check if given node is a pseudo-snippet: a text-only node with explicitly\n * defined children\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isPseudoSnippet(node) {\n    return node.isTextOnly && !!node.children.length;\n}\n\n/**\n * Handles pseudo-snippet node.\n * A pseudo-snippet is a text-only node with explicitly defined children.\n * For such case, we have to figure out if pseudo-snippet contains fields\n * (tab-stops) in node value and “split” it: make contents before field with\n * lowest index node’s “open” part and contents after lowest index — “close”\n * part. With this trick a final output will look like node’s children\n * are nested inside node value\n * @param  {OutputNode} outNode\n * @return {Boolean} Returns “true” if given node is a pseudo-snippets,\n * `false` otherwise\n */\nfunction handlePseudoSnippet(outNode) {\n\tconst node = outNode.node; // original abbreviaiton node\n\n\tif (isPseudoSnippet(node)) {\n\t\tconst fieldsModel = parseFields(node.value);\n\t\tconst field = findLowestIndexField(fieldsModel);\n\t\tif (field) {\n\t\t\tconst parts = splitFieldsModel(fieldsModel, field);\n            outNode.open = outNode.renderFields(parts[0]);\n\t\t\toutNode.close = outNode.renderFields(parts[1]);\n\t\t} else {\n\t\t\toutNode.text = outNode.renderFields(fieldsModel);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Finds field with lowest index in given text\n * @param  {Object} model\n * @return {Object}\n */\nfunction findLowestIndexField(model) {\n\treturn model.fields.reduce((result, field) =>\n\t\t!result || field.index < result.index ? field : result\n\t\t, null);\n}\n\n/**\n * Splits given fields model in two parts by given field\n * @param  {Object} model\n * @param  {Object} field\n * @return {Array} Two-items array\n */\nfunction splitFieldsModel(model, field) {\n\tconst ix = model.fields.indexOf(field);\n\n\tconst left = new model.constructor(\n\t\tmodel.string.slice(0, field.location),\n\t\tmodel.fields.slice(0, ix)\n\t);\n\n\tconst right = new model.constructor(\n\t\tmodel.string.slice(field.location + field.length),\n\t\tmodel.fields.slice(ix + 1)\n\t);\n\n\treturn [left, right];\n}\n\nconst commentOptions = {\n\t// enable node commenting\n\tenabled: false,\n\n\t// attributes that should trigger node commenting on specific node,\n\t// if commenting is enabled\n\ttrigger: ['id', 'class'],\n\n\t// comment before opening tag\n\tbefore: '',\n\n\t// comment after closing tag\n\tafter: '\\n<!-- /[#ID][.CLASS] -->'\n};\n\n/**\n * Renders given parsed Emmet abbreviation as HTML, formatted according to\n * `profile` options\n * @param  {Node}     tree    Parsed Emmet abbreviation\n * @param  {Profile}  profile Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction html(tree, profile, options) {\n\toptions = Object.assign({}, options);\n\toptions.comment = Object.assign({}, commentOptions, options.comment);\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = setFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\tif (node.name) {\n\t\t\t\tconst name = profile.name(node.name);\n\t\t\t\tconst attrs = formatAttributes(outNode, profile);\n\n\t\t\t\toutNode.open = `<${name}${attrs}${node.selfClosing ? profile.selfClose() : ''}>`;\n\t\t\t\tif (!node.selfClosing) {\n\t\t\t\t\toutNode.close = `</${name}>`;\n\t\t\t\t}\n\n\t\t\t\tcommentNode(outNode, options.comment);\n\t\t\t}\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(node.value);\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction setFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\n    if (shouldFormatNode(node, profile)) {\n        outNode.indent = profile.indent(getIndentLevel(node, profile));\n        outNode.newline = '\\n';\n        const prefix = outNode.newline + outNode.indent;\n\n        // do not format the very first node in output\n        if (!isRoot(node.parent) || !isFirstChild(node)) {\n            outNode.beforeOpen = prefix;\n            if (node.isTextOnly) {\n                outNode.beforeText = prefix;\n            }\n        }\n\n        if (hasInnerFormatting(node, profile)) {\n            if (!node.isTextOnly) {\n                outNode.beforeText = prefix + profile.indent(1);\n            }\n            outNode.beforeClose = prefix;\n        }\n    }\n\n    return outNode;\n}\n\n/**\n * Check if given node should be formatted\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction shouldFormatNode(node, profile) {\n\tif (!profile.get('format')) {\n\t\treturn false;\n\t}\n\n    if (node.parent.isTextOnly\n        && node.parent.children.length === 1\n        && parseFields(node.parent.value).fields.length) {\n        // Edge case: do not format the only child of text-only node,\n        // but only if parent contains fields\n        return false;\n    }\n\n\treturn isInline(node, profile) ? shouldFormatInline(node, profile) : true;\n}\n\n/**\n * Check if given inline node should be formatted as well, e.g. it contains\n * enough adjacent siblings that should force formatting\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction shouldFormatInline(node, profile) {\n\tif (!isInline(node, profile)) {\n\t\treturn false;\n\t}\n\n    if (isPseudoSnippet(node)) {\n        return true;\n    }\n\n    // check if inline node is the next sibling of block-level node\n    if (node.childIndex === 0) {\n        // first node in parent: format if it’s followed by a block-level element\n        let next = node;\n        while (next = next.nextSibling) {\n            if (!isInline(next, profile)) {\n                return true;\n            }\n        }\n    } else if (!isInline(node.previousSibling, profile)) {\n        // node is right after block-level element\n        return true;\n    }\n\n    if (profile.get('inlineBreak')) {\n        // check for adjacent inline elements before and after current element\n        let adjacentInline = 1;\n        let before = node, after = node;\n\n        while (isInlineElement((before = before.previousSibling), profile)) {\n            adjacentInline++;\n        }\n\n        while (isInlineElement((after = after.nextSibling), profile)) {\n            adjacentInline++;\n        }\n\n\t\tif (adjacentInline >= profile.get('inlineBreak')) {\n\t\t\treturn true;\n\t\t}\n    }\n\n\t// Another edge case: inline node contains node that should receive foramtting\n\tfor (let i = 0, il = node.children.length; i < il; i++) {\n\t\tif (shouldFormatNode(node.children[i], profile)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n    return false;\n}\n\n/**\n * Check if given node contains inner formatting, e.g. any of its children should\n * be formatted\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction hasInnerFormatting(node, profile) {\n    // check if node if forced for inner formatting\n    const nodeName = (node.name || '').toLowerCase();\n    if (profile.get('formatForce').indexOf(nodeName) !== -1) {\n        return true;\n    }\n\n    // check if any of children should receive formatting\n    // NB don’t use `childrent.some()` to reduce memory allocations\n    for (let i = 0; i < node.children.length; i++) {\n        if (shouldFormatNode(node.children[i], profile)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Outputs attributes of given abbreviation node as HTML attributes\n * @param  {OutputNode} outNode\n * @param  {Profile}    profile\n * @return {String}\n */\nfunction formatAttributes(outNode, profile) {\n\tconst node = outNode.node;\n\n    return node.attributes.map(attr => {\n        if (attr.options.implied && attr.value == null) {\n    \t\treturn null;\n    \t}\n\n    \tconst attrName = profile.attribute(attr.name);\n    \tlet attrValue = null;\n\n        // handle boolean attributes\n    \tif (attr.options.boolean || profile.get('booleanAttributes').indexOf(attrName.toLowerCase()) !== -1) {\n    \t\tif (profile.get('compactBooleanAttributes') && attr.value == null) {\n    \t\t\treturn ` ${attrName}`;\n    \t\t} else if (attr.value == null) {\n    \t\t\tattrValue = attrName;\n    \t\t}\n    \t}\n\n    \tif (attrValue == null) {\n    \t\tattrValue = outNode.renderFields(attr.value);\n    \t}\n\n    \treturn ` ${attrName}=${profile.quote(attrValue)}`;\n    }).join('');\n}\n\n/**\n * Check if given node is inline-level\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInline(node, profile) {\n\treturn (node && node.isTextOnly) || isInlineElement(node, profile);\n}\n\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInlineElement(node, profile) {\n\treturn node && profile.isInline(node);\n}\n\n/**\n * Computes indent level for given node\n * @param  {Node} node\n * @param  {Profile} profile\n * @param  {Number} level\n * @return {Number}\n */\nfunction getIndentLevel(node, profile) {\n\t// Increase indent level IF NOT:\n\t// * parent is text-only node\n\t// * there’s a parent node with a name that is explicitly set to decrease level\n\tconst skip = profile.get('formatSkip') || [];\n\tlet level = node.parent.isTextOnly ? -2 : -1;\n\tlet ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tif (skip.indexOf( (ctx.name || '').toLowerCase() ) === -1) {\n\t\t\tlevel++;\n\t\t}\n\t}\n\n\treturn level < 0 ? 0 : level;\n}\n\n/**\n * Comments given output node, if required\n * @param  {OutputNode} outNode\n * @param  {Object} options\n */\nfunction commentNode(outNode, options) {\n\tconst node = outNode.node;\n\n\tif (!options.enabled || !options.trigger || !node.name) {\n\t\treturn;\n\t}\n\n\tconst attrs = outNode.node.attributes.reduce((out, attr) => {\n\t\tif (attr.name && attr.value != null) {\n\t\t\tout[attr.name.toUpperCase().replace(/-/g, '_')] = attr.value;\n\t\t}\n\n\t\treturn out;\n\t}, {});\n\n\t// add comment only if attribute trigger is present\n\tfor (let i = 0, il = options.trigger.length; i < il; i++) {\n\t\tif (options.trigger[i].toUpperCase() in attrs) {\n\t\t\toutNode.open = template(options.before, attrs) + outNode.open;\n\t\t\tif (outNode.close) {\n\t\t\t\toutNode.close += template(options.after, attrs);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Common utility methods for indent-based syntaxes (Slim, Pug, etc.)\n */\n\nconst reId = /^id$/i;\nconst reClass = /^class$/i;\nconst defaultAttrOptions = {\n\tprimary: attrs => attrs.join(''),\n\tsecondary: attrs => attrs.map(attr => attr.isBoolean ? attr.name : `${attr.name}=${attr.value}`).join(', ')\n};\n\nconst defaultNodeOptions = {\n\topen: null,\n\tclose: null,\n\tomitName: /^div$/i,\n\tattributes: defaultAttrOptions\n};\n\nfunction indentFormat(outNode, profile, options) {\n\toptions = Object.assign({}, defaultNodeOptions, options);\n\tconst node = outNode.node;\n\n\toutNode.indent = profile.indent(getIndentLevel$1(node, profile));\n\toutNode.newline = '\\n';\n\n\t// Do not format the very first node in output\n    if (!isRoot(node.parent) || !isFirstChild(node)) {\n        outNode.beforeOpen = outNode.newline + outNode.indent;\n    }\n\n\tif (node.name) {\n\t\tconst data = Object.assign({\n\t\t\tNAME: profile.name(node.name),\n\t\t\tSELF_CLOSE: node.selfClosing ? options.selfClose : null\n\t\t}, getAttributes(outNode, profile, options.attributes));\n\n\t\t// omit tag name if node has primary attributes\n\t\tif (options.omitName && options.omitName.test(data.NAME) && data.PRIMARY_ATTRS) {\n\t\t\tdata.NAME = null;\n\t\t}\n\n\t\tif (options.open != null) {\n\t\t\toutNode.open = template(options.open, data);\n\t\t}\n\n\t\tif (options.close != null) {\n\t\t\toutNode.close = template(options.close, data);\n\t\t}\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Formats attributes of given node into a string.\n * @param  {OutputNode} node          Output node wrapper\n * @param  {Profile}    profile       Output profile\n * @param  {Object}     options       Additional formatting options\n * @return {String}\n */\nfunction getAttributes(outNode, profile, options) {\n\toptions = Object.assign({}, defaultAttrOptions, options);\n\tconst primary = [], secondary = [];\n\tconst node = outNode.node;\n\n\tnode.attributes.forEach(attr => {\n\t\tif (attr.options.implied && attr.value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst name = profile.attribute(attr.name);\n\t\tconst value = outNode.renderFields(attr.value);\n\n\t\tif (reId.test(name)) {\n\t\t\tvalue && primary.push(`#${value}`);\n\t\t} else if (reClass.test(name)) {\n\t\t\tvalue && primary.push(`.${value.replace(/\\s+/g, '.')}`);\n\t\t} else {\n\t\t\tconst isBoolean = attr.value == null\n\t\t\t\t&& (attr.options.boolean || profile.get('booleanAttributes').indexOf(name.toLowerCase()) !== -1);\n\n\t\t\tsecondary.push({ name, value, isBoolean });\n\t\t}\n\t});\n\n\treturn {\n\t\tPRIMARY_ATTRS: options.primary(primary) || null,\n\t\tSECONDARY_ATTRS: options.secondary(secondary) || null\n\t};\n}\n\n/**\n * Computes indent level for given node\n * @param  {Node} node\n * @param  {Profile} profile\n * @param  {Number} level\n * @return {Number}\n */\nfunction getIndentLevel$1(node, profile) {\n\tlet level = node.parent.isTextOnly ? -2 : -1;\n\tlet ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tlevel++;\n\t}\n\n\treturn level < 0 ? 0 : level;\n}\n\nconst reNl = /\\n|\\r/;\n\n/**\n * Renders given parsed Emmet abbreviation as HAML, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction haml(tree, profile, options) {\n\toptions = options || {};\n\tconst nodeOptions = {\n\t\topen: '[%NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)][SELF_CLOSE]',\n\t\tselfClose: '/',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean\n\t\t\t\t\t? `${attr.name}${profile.get('compactBooleanAttributes') ? '' : '=true'}`\n\t\t\t\t\t: `${attr.name}=${profile.quote(attr.value)}`\n\t\t\t\t).join(' ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue(node, profile));\n\t\t\t}\n\t\t}\n\n        return outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, HAML is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting(outNode, profile) {\n\tconst node = outNode.node;\n\n    if (!node.isTextOnly && node.value) {\n        // node with text: put a space before single-line text\n        outNode.beforeText = reNl.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n    }\n\n\treturn outNode;\n}\n/**\n * Formats value of given node: for multiline text we should add a ` |` suffix\n * at the end of each line. Also ensure that text is perfectly aligned.\n * @param  {Node}    node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue(node, profile) {\n\tif (node.value != null && reNl.test(node.value)) {\n\t\tconst lines = splitByLines(node.value);\n\t\tconst indent = profile.indent(1);\n\t\tconst maxLength = lines.reduce((prev, line) => Math.max(prev, line.length), 0);\n\n\t\treturn lines.map((line, i) => `${i ? indent : ''}${pad(line, maxLength)} |`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\nfunction pad(text, len) {\n\twhile (text.length < len) {\n\t\ttext += ' ';\n\t}\n\n\treturn text;\n}\n\nconst reNl$1 = /\\n|\\r/;\nconst secondaryAttrs = {\n\tnone:   '[ SECONDARY_ATTRS]',\n\tround:  '[(SECONDARY_ATTRS)]',\n\tcurly:  '[{SECONDARY_ATTRS}]',\n\tsquare: '[[SECONDARY_ATTRS]'\n};\n\n/**\n * Renders given parsed Emmet abbreviation as Slim, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction slim(tree, profile, options) {\n\toptions = options || {};\n\tconst SECONDARY_ATTRS = options.attributeWrap\n\t\t&& secondaryAttrs[options.attributeWrap]\n\t\t|| secondaryAttrs.none;\n\n\tconst booleanAttr = SECONDARY_ATTRS === secondaryAttrs.none\n\t\t? attr => `${attr.name}=true`\n\t\t: attr => attr.name;\n\n\tconst nodeOptions = {\n\t\topen: `[NAME][PRIMARY_ATTRS]${SECONDARY_ATTRS}[SELF_CLOSE]`,\n\t\tselfClose: '/',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean\n\t\t\t\t\t? booleanAttr(attr)\n\t\t\t\t\t: `${attr.name}=${profile.quote(attr.value)}`\n\t\t\t\t).join(' ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, (outNode, renderFields) => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting$1(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue$1(node, profile));\n\t\t\t}\n\t\t}\n\n        return outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, Slim is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting$1(outNode, profile) {\n\tconst node = outNode.node;\n\tconst parent = node.parent;\n\n\t// Edge case: a single inline-level child inside node without text:\n\t// allow it to be inlined\n\tif (profile.get('inlineBreak') === 0 && isInline$1(node, profile)\n\t\t&& !isRoot(parent) && parent.value == null && parent.children.length === 1) {\n\t\toutNode.beforeOpen = ': ';\n\t}\n\n    if (!node.isTextOnly && node.value) {\n        // node with text: put a space before single-line text\n        outNode.beforeText = reNl$1.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n    }\n\n\treturn outNode;\n}\n\n/**\n * Formats value of given node: for multiline text we should precede each\n * line with `| ` with one-level deep indent\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue$1(node, profile) {\n\tif (node.value != null && reNl$1.test(node.value)) {\n\t\tconst indent = profile.indent(1);\n\t\treturn splitByLines(node.value).map((line, i) => `${indent}${i ? ' ' : '|'} ${line}`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\n/**\n * Check if given node is inline-level\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInline$1(node, profile) {\n\treturn node && (node.isTextOnly || profile.isInline(node));\n}\n\nconst reNl$2 = /\\n|\\r/;\n\n/**\n * Renders given parsed Emmet abbreviation as Pug, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction pug(tree, profile, options) {\n\toptions = options || {};\n\tconst nodeOptions = {\n\t\topen: '[NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)]',\n\t\tattributes: {\n\t\t\tsecondary(attrs) {\n\t\t\t\treturn attrs.map(attr => attr.isBoolean ? attr.name : `${attr.name}=${profile.quote(attr.value)}`).join(', ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, outNode => {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting$2(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tconst node = outNode.node;\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue$2(node, profile));\n\t\t\t}\n\t\t}\n\n        return outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, Pug is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting$2(outNode, profile) {\n\tconst node = outNode.node;\n\n    if (!node.isTextOnly && node.value) {\n        // node with text: put a space before single-line text\n        outNode.beforeText = reNl$2.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n    }\n\n\treturn outNode;\n}\n\n/**\n * Formats value of given node: for multiline text we should precede each\n * line with `| ` with one-level deep indent\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue$2(node, profile) {\n\tif (node.value != null && reNl$2.test(node.value)) {\n\t\tconst indent = profile.indent(1);\n\t\treturn splitByLines(node.value).map(line => `${indent}| ${line}`).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\nconst supportedSyntaxed = { html, haml, slim, pug };\n\n/**\n * Outputs given parsed abbreviation in specified syntax\n * @param {Node}     tree     Parsed abbreviation tree\n * @param {Profile}  profile  Output profile\n * @param {String}   [syntax] Output syntax. If not given, `html` syntax is used\n * @param {Function} options.field A function to output field/tabstop for\n * host editor. This function takes two arguments: `index` and `placeholder` and\n * should return a string that represents tabstop in host editor. By default\n * only a placeholder is returned\n * @example\n * {\n * \tfield(index, placeholder) {\n * \t\t// return field in TextMate-style, e.g. ${1} or ${2:foo}\n * \t\treturn `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n *  }\n * }\n * @return {String}\n */\nvar index = function(tree, profile, syntax, options) {\n\tif (typeof syntax === 'object') {\n\t\toptions = syntax;\n\t\tsyntax = null;\n\t}\n\n\tif (!supports(syntax)) {\n\t\t// fallback to HTML if given syntax is not supported\n\t\tsyntax = 'html';\n\t}\n\n\treturn supportedSyntaxed[syntax](tree, profile, options);\n};\n\n/**\n * Check if given syntax is supported\n * @param {String} syntax\n * @return {Boolean}\n */\nfunction supports(syntax) {\n\treturn !!syntax && syntax in supportedSyntaxed;\n}\n\nexport { supports };export default index;\n","import Node from '@emmetio/node';\nimport StreamReader from '@emmetio/stream-reader';\nimport { eatQuoted, isAlpha, isNumber, isWhiteSpace } from '@emmetio/stream-reader-utils';\n\n/**\n * A wrapper for holding CSS value\n */\nclass CSSValue {\n\tconstructor() {\n\t\tthis.type = 'css-value';\n\t\tthis.value = [];\n\t}\n\n\tget size() {\n\t\treturn this.value.length;\n\t}\n\n\tadd(value) {\n\t\tthis.value.push(value);\n\t}\n\n\thas(value) {\n\t\treturn this.value.indexOf(value) !== -1;\n\t}\n\n\ttoString() {\n\t\treturn this.value.join(' ');\n\t}\n}\n\nconst HASH = 35; // #\nconst DOT  = 46; // .\n\n/**\n * Consumes a color token from given string\n * @param  {StreamReader} stream\n * @return {Color} Returns consumend color object, `undefined` otherwise\n */\nvar consumeColor = function(stream) {\n\t// supported color variations:\n\t// #abc   → #aabbccc\n\t// #0     → #000000\n\t// #fff.5 → rgba(255, 255, 255, 0.5)\n\t// #t     → transparent\n\tif (stream.peek() === HASH) {\n\t\tstream.start = stream.pos;\n\t\tstream.next();\n\n\t\tstream.eat(116) /* t */ || stream.eatWhile(isHex);\n\t\tconst base = stream.current();\n\n\t\t// a hex color can be followed by `.num` alpha value\n\t\tstream.start = stream.pos;\n\t\tif (stream.eat(DOT) && !stream.eatWhile(isNumber)) {\n\t\t\tthrow stream.error('Unexpected character for alpha value of color');\n\t\t}\n\n\t\treturn new Color(base, stream.current());\n\t}\n};\n\nclass Color {\n\tconstructor(value, alpha) {\n\t\tthis.type = 'color';\n\t\tthis.raw = value;\n\t\tthis.alpha = Number(alpha != null && alpha !== '' ? alpha : 1);\n\t\tvalue = value.slice(1); // remove #\n\n\t\tlet r = 0, g = 0, b = 0;\n\n\t\tif (value === 't') {\n\t\t\tthis.alpha = 0;\n\t\t} else {\n\t\t\tswitch (value.length) {\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tr = g = b = value + value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tr = g = b = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tr = value[0] + value[0];\n\t\t\t\t\tg = value[1] + value[1];\n\t\t\t\t\tb = value[2] + value[2];\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tvalue += value;\n\t\t\t\t\tr = value.slice(0, 2);\n\t\t\t\t\tg = value.slice(2, 4);\n\t\t\t\t\tb = value.slice(4, 6);\n\t\t\t}\n\t\t}\n\n\t\tthis.r = parseInt(r, 16);\n\t\tthis.g = parseInt(g, 16);\n\t\tthis.b = parseInt(b, 16);\n\t}\n\n\t/**\n\t * Output current color as hex value\n\t * @param {Boolean} shor Produce short value (e.g. #fff instead of #ffffff), if possible\n\t * @return {String}\n\t */\n\ttoHex(short) {\n\t\tconst fn = (short && isShortHex(this.r) && isShortHex(this.g) && isShortHex(this.b))\n\t\t\t? toShortHex : toHex;\n\n\t\treturn '#' + fn(this.r)  + fn(this.g) + fn(this.b);\n\t}\n\n\t/**\n\t * Output current color as `rgba?(...)` CSS color\n\t * @return {String}\n\t */\n\ttoRGB() {\n\t\tconst values = [this.r, this.g, this.b];\n\t\tif (this.alpha !== 1) {\n\t\t\tvalues.push(this.alpha.toFixed(8).replace(/\\.?0+$/, ''));\n\t\t}\n\n\t\treturn `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n\t}\n\n\ttoString(short) {\n\t\tif (!this.r && !this.g && !this.b && !this.alpha) {\n\t\t\treturn 'transparent';\n\t\t}\n\t\treturn this.alpha === 1 ? this.toHex(short) : this.toRGB();\n\t}\n}\n\n/**\n * Check if given code is a hex value (/0-9a-f/)\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isHex(code) {\n\treturn isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\n\nfunction isShortHex(hex) {\n\treturn !(hex % 17);\n}\n\nfunction toShortHex(num) {\n\treturn (num >> 4).toString(16);\n}\n\nfunction toHex(num) {\n\treturn pad(num.toString(16), 2);\n}\n\nfunction pad(value, len) {\n\twhile (value.length < len) {\n\t\tvalue = '0' + value;\n\t}\n\treturn value;\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaNumericWord(code) {\n\treturn isNumber(code) || isAlphaWord(code);\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaWord(code) {\n\treturn code === 95 /* _ */ || isAlpha(code);\n}\n\nconst PERCENT = 37; // %\nconst DOT$1     = 46; // .\nconst DASH$1    = 45; // -\n\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n * @param  {StreamReader} stream\n * @return {NumericValue}\n */\nvar consumeNumericValue = function(stream) {\n\tstream.start = stream.pos;\n\tif (eatNumber(stream)) {\n\t\tconst num = stream.current();\n\t\tstream.start = stream.pos;\n\n\t\t// eat unit, which can be a % or alpha word\n\t\tstream.eat(PERCENT) || stream.eatWhile(isAlphaWord);\n\t\treturn new NumericValue(num, stream.current());\n\t}\n};\n\n/**\n * A numeric CSS value with optional unit\n */\nclass NumericValue {\n\tconstructor(value, unit) {\n\t\tthis.type = 'numeric';\n\t\tthis.value = Number(value);\n\t\tthis.unit = unit || '';\n\t}\n\n\ttoString() {\n\t\treturn `${this.value}${this.unit}`;\n\t}\n}\n\n/**\n * Eats number value from given stream\n * @param  {StreamReader} stream\n * @return {Boolean} Returns `true` if number was consumed\n */\nfunction eatNumber(stream) {\n\tconst start = stream.pos;\n\tconst negative = stream.eat(DASH$1);\n\tlet hadDot = false, consumed = false, code;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\n\t\t// either a second dot or not a number: stop parsing\n\t\tif (code === DOT$1 ? hadDot : !isNumber(code)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconsumed = true;\n\n\t\tif (code === DOT$1) {\n\t\t\thadDot = true;\n\t\t}\n\n\t\tstream.next();\n\t}\n\n\tif (negative && !consumed) {\n\t\t// edge case: consumed dash only, bail out\n\t\tstream.pos = start;\n\t}\n\n\treturn start !== stream.pos;\n}\n\nconst DOLLAR$1 = 36; // $\nconst DASH$2   = 45; // -\nconst AT$1     = 64; // @\n\n/**\n * Consumes a keyword: either a variable (a word that starts with $ or @) or CSS\n * keyword or shorthand\n * @param  {StreamReader} stream\n * @param  {Boolean} [short] Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n * @return {String} Consumed variable\n */\nvar consumeKeyword = function(stream, short) {\n\tstream.start = stream.pos;\n\n\tif (stream.eat(DOLLAR$1) || stream.eat(AT$1)) {\n\t\t// SCSS or LESS variable\n\t\tstream.eatWhile(isVariableName);\n\t} else if (short) {\n\t\tstream.eatWhile(isAlphaWord);\n\t} else {\n\t\tstream.eatWhile(isKeyword);\n\t}\n\n\treturn stream.start !== stream.pos ? new Keyword(stream.current()) : null;\n};\n\nclass Keyword {\n\tconstructor(value) {\n\t\tthis.type = 'keyword';\n\t\tthis.value = value;\n\t}\n\n\ttoString() {\n\t\treturn this.value;\n\t}\n}\n\nfunction isKeyword(code) {\n\treturn isAlphaNumericWord(code) || code === DASH$2;\n}\n\nfunction isVariableName(code) {\n\treturn code === 45 /* - */ || isAlphaNumericWord(code);\n}\n\nconst opt = { throws: true };\n\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @param  {StreamReader} stream\n * @return {String}\n */\nvar consumeQuoted = function(stream) {\n\tif (eatQuoted(stream, opt)) {\n\t\treturn new QuotedString(stream.current());\n\t}\n};\n\nclass QuotedString {\n\tconstructor(value) {\n\t\tthis.type = 'string';\n\t\tthis.value = value;\n\t}\n\n\ttoString() {\n\t\treturn this.value;\n\t}\n}\n\nconst LBRACE = 40; // (\nconst RBRACE = 41; // )\nconst COMMA  = 44; // ,\n\n/**\n * Consumes arguments from given string.\n * Arguments are comma-separated list of CSS values inside round braces, e.g.\n * `(1, a2, 'a3')`. Nested lists and quoted strings are supported\n * @param  {StreamReader} stream\n * @return {Array}        Array of arguments, `null` if arguments cannot be consumed\n */\nfunction consumeArgumentList(stream) {\n\tif (!stream.eat(LBRACE)) {\n\t\t// not an argument list\n\t\treturn null;\n\t}\n\n\tlet level = 1, code, arg;\n\tconst argsList = [];\n\n\twhile (!stream.eof()) {\n\t\tif (arg = consumeArgument(stream)) {\n\t\t\targsList.push(arg);\n\t\t} else {\n\t\t\t// didn’t consumed argument, expect argument separator or end-of-arguments\n\t\t\tstream.eatWhile(isWhiteSpace);\n\n\t\t\tif (stream.eat(RBRACE)) {\n\t\t\t\t// end of arguments list\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!stream.eat(COMMA)) {\n\t\t\t\tthrow stream.error('Expected , or )');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn argsList;\n}\n\n/**\n * Consumes a single argument. An argument is a `CSSValue`, e.g. it could be\n * a space-separated string of value\n * @param  {StreamReader} stream\n * @return {CSSValue}\n */\nfunction consumeArgument(stream) {\n\tconst result = new CSSValue();\n\tlet value;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isWhiteSpace);\n\t\tvalue = consumeNumericValue(stream) || consumeColor(stream)\n\t\t\t|| consumeQuoted(stream) || consumeKeywordOrFunction(stream);\n\n\t\tif (!value) {\n\t\t\tbreak;\n\t\t}\n\n\t\tresult.add(value);\n\t}\n\n\treturn result.size ? result : null;\n}\n\n/**\n * Consumes either function call like `foo()` or keyword like `foo`\n * @param  {StreamReader} stream\n * @return {Keyword|FunctionCall}\n */\nfunction consumeKeywordOrFunction(stream) {\n\tconst kw = consumeKeyword(stream);\n\tif (kw) {\n\t\tconst args = consumeArgumentList(stream);\n\t\treturn args ? new FunctionCall(kw.toString(), args) : kw;\n\t}\n}\n\nclass FunctionCall {\n\t/**\n\t * @param {String} name Function name\n\t * @param {Array}  args Function arguments\n\t */\n\tconstructor(name, args) {\n\t\tthis.type = 'function';\n\t\tthis.name = name;\n\t\tthis.args = args || [];\n\t}\n\n\ttoString() {\n\t\treturn `${this.name}(${this.args.join(', ')})`;\n\t}\n}\n\nconst EXCL   = 33; // !\nconst DOLLAR = 36; // $\nconst PLUS   = 43; // +\nconst DASH   = 45; // -\nconst COLON  = 58; // :\nconst AT     = 64; // @\n\n/**\n * Parses given Emmet CSS abbreviation and returns it as parsed Node tree\n * @param {String} abbr\n * @return {Node}\n */\nvar index = function(abbr) {\n\tconst root = new Node();\n\tconst stream = new StreamReader(abbr);\n\tlet node;\n\n\twhile (!stream.eof()) {\n\t\tlet node = new Node(consumeIdent(stream));\n\t\tnode.value = consumeValue(stream);\n\n\t\tconst args = consumeArgumentList(stream);\n\t\tif (args) {\n\t\t\t// technically, arguments in CSS are anonymous Emmet Node attributes,\n\t\t\t// but since Emmet can support only one anonymous, `null`-name\n\t\t\t// attribute (for good reasons), we’ll use argument index as name\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tnode.setAttribute(String(i), args[i]);\n\t\t\t}\n\t\t}\n\n\t\t// Consume `!important` modifier at the end of expression\n\t\tif (stream.eat(EXCL)) {\n\t\t\tnode.value.add('!');\n\t\t}\n\n\t\troot.appendChild(node);\n\n\t\t// CSS abbreviations cannot be nested, only listed\n\t\tif (!stream.eat(PLUS)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!stream.eof()) {\n\t\tthrow stream.error('Unexpected character');\n\t}\n\n\treturn root;\n};\n\n/**\n * Consumes CSS property identifier from given stream\n * @param  {StreamReader} stream\n * @return {String}\n */\nfunction consumeIdent(stream) {\n\tstream.start = stream.pos;\n\tstream.eatWhile(isIdentPrefix);\n\tstream.eatWhile(isIdent);\n\treturn stream.start !== stream.pos ? stream.current() : null;\n}\n\n/**\n * Consumes embedded value from Emmet CSS abbreviation stream\n * @param  {StreamReader} stream\n * @return {CSSValue}\n */\nfunction consumeValue(stream) {\n\tconst values = new CSSValue();\n\tlet value;\n\n\twhile (!stream.eof()) {\n\t\t// use colon as value separator\n\t\tstream.eat(COLON);\n\t\tif (value = consumeNumericValue(stream) || consumeColor(stream)) {\n\t\t\t// edge case: a dash after unit-less numeric value or color should\n\t\t\t// be treated as value separator, not negative sign\n\t\t\tif (!value.unit) {\n\t\t\t\tstream.eat(DASH);\n\t\t\t}\n\t\t} else {\n\t\t\tstream.eat(DASH);\n\t\t\tvalue = consumeKeyword(stream, true);\n\t\t}\n\n\t\tif (!value) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvalues.add(value);\n\t}\n\n\treturn values;\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isIdent(code) {\n\treturn isAlphaWord(code);\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isIdentPrefix(code) {\n\treturn code === AT || code === DOLLAR || code === EXCL;\n}\n\nexport default index;\n","const DASH = 45; // -\n\n/**\n * Calculates fuzzy match score of how close `abbr` matches given `string`.\n * @param  {String} abbr        Abbreviation to score\n * @param  {String} string      String to match\n * @param  {Number} [fuzziness] Fuzzy factor\n * @return {Number}             Match score\n */\nvar stringScore = function(abbr, string) {\n    if (abbr === string) {\n        return 1;\n    }\n\n    // a string MUST start with the same character as abbreviation\n    if (!string || abbr.charCodeAt(0) !== string.charCodeAt(0)) {\n        return 0;\n    }\n\n    const abbrLength = abbr.length;\n    const stringLength = string.length;\n    let i = 1, j = 1, score = stringLength;\n    let ch1, ch2, found, acronym;\n\n    while (i < abbrLength) {\n        ch1 = abbr.charCodeAt(i);\n        found = false;\n        acronym = false;\n\n        while (j < stringLength) {\n            ch2 = string.charCodeAt(j);\n\n            if (ch1 === ch2) {\n                found = true;\n                score += (stringLength - j) * (acronym ? 2 : 1);\n                break;\n            }\n\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === DASH;\n            j++;\n        }\n\n        if (!found) {\n            break;\n        }\n\n        i++;\n    }\n\n    return score && score * (i / abbrLength) / sum(stringLength);\n};\n\n/**\n * Calculates sum of first `n` natural numbers, e.g. 1+2+3+...n\n * @param  {Number} n\n * @return {Number}\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nconst reProperty = /^([a-z\\-]+)(?:\\s*:\\s*([^\\n\\r]+))?$/;\nconst DASH$1 = 45; // -\n\n/**\n * Creates a special structure for resolving CSS properties from plain CSS\n * snippets.\n * Almost all CSS snippets are aliases for real CSS properties with available\n * value variants, optionally separated by `|`. Most values are keywords that\n * can be fuzzy-resolved as well. Some CSS properties are shorthands for other,\n * more specific properties, like `border` and `border-style`. For such cases\n * keywords from more specific properties should be available in shorthands too.\n * @param {Snippet[]} snippets\n * @return {CSSSnippet[]}\n */\nvar cssSnippets = function(snippets) {\n    return nest( snippets.map(snippet => new CSSSnippet(snippet.key, snippet.value)) );\n};\n\nclass CSSSnippet {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.property = null;\n\n        // detect if given snippet is a property\n        const m = value && value.match(reProperty);\n        if (m) {\n            this.property = m[1];\n            this.value = m[2];\n        }\n\n        this.dependencies = [];\n    }\n\n    addDependency(dep) {\n        this.dependencies.push(dep);\n    }\n\n    get defaulValue() {\n        return this.value != null ? splitValue(this.value)[0] : null;\n    }\n\n    /**\n     * Returns list of unique keywords for current CSS snippet and its dependencies\n     * @return {String[]}\n     */\n    keywords() {\n        const stack = [];\n        const keywords = new Set();\n        let i = 0, item, candidates;\n\n        if (this.property) {\n            // scan valid CSS-properties only\n            stack.push(this);\n        }\n\n        while (i < stack.length) {\n            // NB Keep items in stack instead of push/pop to avoid possible\n            // circular references\n            item = stack[i++];\n\n            if (item.value) {\n                candidates = splitValue(item.value).filter(isKeyword$1);\n\n                // extract possible keywords from snippet value\n                for (let j = 0; j < candidates.length; j++) {\n                    keywords.add(candidates[j].trim());\n                }\n\n                // add dependencies into scan stack\n                for (let j = 0, deps = item.dependencies; j < deps.length; j++) {\n                    if (stack.indexOf(deps[j]) === -1) {\n                        stack.push(deps[j]);\n                    }\n                }\n            }\n        }\n\n        return Array.from(keywords);\n    }\n}\n\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * background-position-x -> background-position -> background\n * @param  {CSSSnippet[]} snippets\n * @return {CSSSnippet[]}\n */\nfunction nest(snippets) {\n    snippets = snippets.sort(snippetsSort);\n    const stack = [];\n\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // backgound -> background-position -> background-position-x\n    for (let i = 0, cur, prev; i < snippets.length; i++) {\n        cur = snippets[i];\n\n        if (!cur.property) {\n            // not a CSS property, skip it\n            continue;\n        }\n\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n\n            if (cur.property.indexOf(prev.property) === 0\n                && cur.property.charCodeAt(prev.property.length) === DASH$1) {\n                prev.addDependency(cur);\n                stack.push(cur);\n                break;\n            }\n\n            stack.pop();\n        }\n\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n\n    return snippets;\n}\n\n/**\n * A sorting function for array of snippets\n * @param  {CSSSnippet} a\n * @param  {CSSSnippet} b\n * @return {Number}\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n\n    return a.key < b.key ? -1 : 1;\n}\n\n/**\n * Check if given string is a keyword candidate\n * @param  {String}  str\n * @return {Boolean}\n */\nfunction isKeyword$1(str) {\n    return /^\\s*[\\w\\-]+/.test(str);\n}\n\nfunction splitValue(value) {\n    return String(value).split('|');\n}\n\nconst globalKeywords = ['auto', 'inherit', 'unset'];\nconst unitlessProperties = [\n    'z-index', 'line-height', 'opacity', 'font-weight', 'zoom',\n    'flex', 'flex-grow', 'flex-shrink'\n];\nconst unitAliases = {\n    e :'em',\n    p: '%',\n    x: 'ex',\n    r: 'rem'\n};\n\n/**\n * For every node in given `tree`, finds matching snippet from `registry` and\n * updates node with snippet data.\n *\n * This resolver uses fuzzy matching for searching matched snippets and their\n * keyword values.\n */\n\nvar index = function(tree, registry) {\n\tconst snippets = convertToCSSSnippets(registry);\n\ttree.walk(node => resolveNode(node, snippets));\n\treturn tree;\n};\n\nfunction convertToCSSSnippets(registry) {\n    return cssSnippets(registry.all({type: 'string'}))\n}\n\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n * @param  {Node} node\n * @param  {CSSSnippet[]} snippets\n * @return {Node}\n */\nfunction resolveNode(node, snippets) {\n\tconst snippet = findBestMatch(node.name, snippets, 'key');\n\n\tif (!snippet) {\n\t\t// Edge case: `!important` snippet\n\t\treturn node.name === '!' ? setNodeAsText(node, '!important') : node;\n\t}\n\n\treturn snippet.property\n\t\t? resolveAsProperty(node, snippet)\n\t\t: resolveAsSnippet(node, snippet);\n}\n\n/**\n * Resolves given parsed abbreviation node as CSS propery\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @return {Node}\n */\nfunction resolveAsProperty(node, snippet) {\n    const abbr = node.name;\n\tnode.name = snippet.property;\n\n\tif (node.value && typeof node.value === 'object') {\n\t\t// resolve keyword shortcuts\n\t\tconst keywords = snippet.keywords();\n\n\t\tif (!node.value.size) {\n\t\t\t// no value defined, try to resolve unmatched part as a keyword alias\n\t\t\tlet kw = findBestMatch(getUnmatchedPart(abbr, snippet.key), keywords);\n\n            if (!kw) {\n                // no matching value, try to get default one\n                kw = snippet.defaulValue;\n                if (kw && kw.indexOf('${') === -1) {\n                    // Quick and dirty test for existing field. If not, wrap\n                    // default value in a field\n                    kw = `\\${1:${kw}}`;\n                }\n            }\n\n\t\t\tif (kw) {\n\t\t\t\tnode.value.add(kw);\n\t\t\t}\n\t\t} else {\n\t\t\t// replace keyword aliases in current node value\n\t\t\tfor (let i = 0, token; i < node.value.value.length; i++) {\n\t\t\t\ttoken = node.value.value[i];\n\n\t\t\t\tif (token === '!') {\n\t\t\t\t\ttoken = `${!i ? '${1} ' : ''}!important`;\n\t\t\t\t} else if (isKeyword(token)) {\n\t\t\t\t\ttoken = findBestMatch(token.value, keywords)\n\t\t\t\t\t\t|| findBestMatch(token.value, globalKeywords)\n\t\t\t\t\t\t|| token;\n\t\t\t\t} else if (isNumericValue(token)) {\n                    token = resolveNumericValue(node.name, token);\n                }\n\n                node.value.value[i] = token;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node;\n}\n\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @return {Node}\n */\nfunction resolveAsSnippet(node, snippet) {\n\treturn setNodeAsText(node, snippet.value);\n}\n\n/**\n * Sets given parsed abbreviation node as a text snippet\n * @param {Node} node\n * @param {String} text\n * @return {Node}\n */\nfunction setNodeAsText(node, text) {\n\tnode.name = null;\n\tnode.value = text;\n\treturn node;\n}\n\n/**\n * Finds best matching item from `items` array\n * @param {String} abbr  Abbreviation to match\n * @param {Array}  items List of items for match\n * @param {String} [key] If `items` is a list of objects, use `key` as object\n * property to test against\n * @return {*}\n */\nfunction findBestMatch(abbr, items, key) {\n\tif (!abbr) {\n\t\treturn null;\n\t}\n\n\tlet matchedItem = null;\n\tlet maxScore = 0;\n\n\tfor (let i = 0, item; i < items.length; i++) {\n\t\titem = items[i];\n\t\tconst score = stringScore(abbr, getScoringPart(item, key));\n\n\t\tif (score === 1) {\n\t\t\t// direct hit, no need to look further\n\t\t\treturn item;\n\t\t}\n\n\t\tif (score && score >= maxScore) {\n\t\t\tmaxScore = score;\n\t\t\tmatchedItem = item;\n\t\t}\n\t}\n\n\treturn matchedItem;\n}\n\nfunction getScoringPart(item, key) {\n    const value = item && typeof item === 'object' ? item[key] : item;\n    const m = (value || '').match(/^[\\w-@]+/);\n    return m ? m[0] : value;\n}\n\n/**\n * Returns a part of `abbr` that wasn’t directly matched agains `string`.\n * For example, if abbreviation `poas` is matched against `position`, the unmatched part will be `as`\n * since `a` wasn’t found in string stream\n * @param {String} abbr\n * @param {String} string\n * @return {String}\n */\nfunction getUnmatchedPart(abbr, string) {\n\tfor (let i = 0, lastPos = 0; i < abbr.length; i++) {\n\t\tlastPos = string.indexOf(abbr[i], lastPos);\n\t\tif (lastPos === -1) {\n\t\t\treturn abbr.slice(i);\n\t\t}\n        lastPos++;\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if given CSS value token is a keyword\n * @param {*} token\n * @return {Boolean}\n */\nfunction isKeyword(token) {\n\treturn tokenTypeOf(token, 'keyword');\n}\n\n/**\n * Check if given CSS value token is a numeric value\n * @param  {*}  token\n * @return {Boolean}\n */\nfunction isNumericValue(token) {\n    return tokenTypeOf(token, 'numeric');\n}\n\nfunction tokenTypeOf(token, type) {\n\treturn token && typeof token === 'object' && token.type === type;\n}\n\n/**\n * Resolves numeric value for given CSS property\n * @param  {String} property    CSS property name\n * @param  {NumericValue} token CSS numeric value token\n * @return {NumericValue}\n */\nfunction resolveNumericValue(property, token) {\n    if (token.unit) {\n        token.unit = unitAliases[token.unit] || token.unit;\n    } else if (token.value !== 0 && unitlessProperties.indexOf(property) === -1) {\n        // use `px` for integers, `em` for floats\n        // NB: num|0 is a quick alternative to Math.round(0)\n        token.unit = token.value === (token.value|0) ? 'px' : 'em';\n    }\n\n    return token;\n}\n\nexport { convertToCSSSnippets, stringScore, cssSnippets };export default index;\n","import render from '@emmetio/output-renderer';\nimport parseFields from '@emmetio/field-parser';\n\nconst defaultOptions = {\n\tshortHex: true,\n\tformat: {\n\t\tbetween: ': ',\n\t\tafter: ';'\n\t}\n};\n\n/**\n * Renders given parsed Emmet CSS abbreviation as CSS-like\n * stylesheet, formatted according to `profile` options\n * @param  {Node}     tree    Parsed Emmet abbreviation\n * @param  {Profile}  profile Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction css(tree, profile, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\n\treturn render(tree, options.field, outNode => {\n\t\tconst node = outNode.node;\n\t\tlet value = String(node.value || '');\n\n\t\tif (node.attributes.length) {\n\t\t\tconst fieldValues = node.attributes.map(attr => stringifyAttribute(attr, options));\n\t\t\tvalue = injectFields(value, fieldValues);\n\t\t}\n\n\t\toutNode.open = node.name && profile.name(node.name);\n\t\toutNode.afterOpen = options.format.between;\n\t\toutNode.text = outNode.renderFields(value || null);\n\n\t\tif (outNode.open) {\n\t\t\toutNode.afterText = options.format.after;\n\t\t}\n\n\t\tif (profile.get('format')) {\n\t\t\toutNode.newline = '\\n';\n\t\t\tif (tree.lastChild !== node) {\n\t\t\t\toutNode.afterText += outNode.newline;\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Injects given field values at each field of given string\n * @param  {String}   string\n * @param  {String[]} attributes\n * @return {FieldString}\n */\nfunction injectFields(string, values) {\n\tconst fieldsModel = parseFields(string);\n\tconst fieldsAmount = fieldsModel.fields.length;\n\n\tif (fieldsAmount) {\n\t\tvalues = values.slice();\n\t\tif (values.length > fieldsAmount) {\n\t\t\t// More values that output fields: collapse rest values into\n\t\t\t// a single token\n\t\t\tvalues = values.slice(0, fieldsAmount - 1)\n\t\t\t\t.concat(values.slice(fieldsAmount - 1).join(', '));\n\t\t}\n\n\t\twhile (values.length) {\n\t\t\tconst value = values.shift();\n\t\t\tconst field = fieldsModel.fields.shift();\n\t\t\tconst delta = value.length - field.length;\n\n\t\t\tfieldsModel.string = fieldsModel.string.slice(0, field.location)\n\t\t\t\t+ value\n\t\t\t\t+ fieldsModel.string.slice(field.location + field.length);\n\n\t\t\t// Update location of the rest fields in string\n\t\t\tfor (let i = 0, il = fieldsModel.fields.length; i < il; i++) {\n\t\t\t\tfieldsModel.fields[i].location += delta;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fieldsModel;\n}\n\nfunction stringifyAttribute(attr, options) {\n\tif (attr.value && typeof attr.value === 'object' && attr.value.type === 'css-value') {\n\t\treturn attr.value.value\n\t\t.map(token => {\n\t\t\tif (token && typeof token === 'object') {\n\t\t\t\treturn token.type === 'color'\n\t\t\t\t\t? token.toString(options.shortHex)\n\t\t\t\t\t: token.toString();\n\t\t\t}\n\n\t\t\treturn String(token);\n\t\t})\n\t\t.join(' ');\n\t}\n\n\treturn attr.value != null ? String(attr.value) : '';\n}\n\nconst syntaxFormat = {\n\tcss: {\n\t\tbetween: ': ',\n\t\tafter: ';'\n\t},\n\tscss: 'css',\n\tless: 'css',\n\tsass: {\n\t\tbetween: ': ',\n\t\tafter: ''\n\t},\n\tstylus: {\n\t\tbetween: ' ',\n\t\tafter: ''\n\t}\n};\n\n/**\n * Outputs given parsed abbreviation in specified stylesheet syntax\n * @param {Node}     tree     Parsed abbreviation tree\n * @param {Profile}  profile  Output profile\n * @param {String}   [syntax] Output syntax. If not given, `css` syntax is used\n * @param {Function} options.field A function to output field/tabstop for\n * host editor. This function takes two arguments: `index` and `placeholder` and\n * should return a string that represents tabstop in host editor. By default\n * only a placeholder is returned\n * @example\n * {\n * \tfield(index, placeholder) {\n * \t\t// return field in TextMate-style, e.g. ${1} or ${2:foo}\n * \t\treturn `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n *  }\n * }\n * @return {String}\n */\nvar index = function(tree, profile, syntax, options) {\n\tif (typeof syntax === 'object') {\n\t\toptions = syntax;\n\t\tsyntax = null;\n\t}\n\n\tif (!supports(syntax)) {\n\t\t// fallback to CSS if given syntax is not supported\n\t\tsyntax = 'css';\n\t}\n\n\toptions = Object.assign({}, options, {\n\t\tformat: getFormat(syntax, options)\n\t});\n\n\t// CSS abbreviations doesn’t support nesting so simply\n\t// output root node children\n\treturn css(tree, profile, options);\n};\n\n/**\n * Check if given syntax is supported\n * @param {String} syntax\n * @return {Boolean}\n */\nfunction supports(syntax) {\n\treturn !!syntax && syntax in syntaxFormat;\n}\n\n/**\n * Returns formatter object for given syntax\n * @param  {String} syntax\n * @param  {Object} [options]\n * @return {Object} Formatter object as defined in `syntaxFormat`\n */\nfunction getFormat(syntax, options) {\n\tlet format = syntaxFormat[syntax];\n\tif (typeof format === 'string') {\n\t\tformat = syntaxFormat[format];\n\t}\n\n\treturn Object.assign({}, format, options && options.format);\n}\n\nexport { supports };export default index;\n","import resolveImplicitTag from '@emmetio/implicit-tag';\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst langs = { latin, ru, sp };\n\nconst defaultOptions = {\n\twordCount: 30,\n\tskipCommon: false,\n\tlang: 'latin'\n};\n\n/**\n * Replaces given parsed Emmet abbreviation node with nodes filled with\n * Lorem Ipsum stub text.\n * @param {Node} node\n * @return {Node}\n */\nvar index = function(node, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\tconst dict = langs[options.lang] || langs.latin;\n    const startWithCommon = !options.skipCommon && !isRepeating(node);\n\n\tif (!node.repeat && !isRoot(node.parent)) {\n\t\t// non-repeating element, insert text stub as a content of parent node\n\t\t// and remove current one\n\t\tnode.parent.value = paragraph(dict, options.wordCount, startWithCommon);\n\t\tnode.remove();\n\t} else {\n\t\t// Replace named node with generated content\n\t\tnode.value = paragraph(dict, options.wordCount, startWithCommon);\n\t\tnode.name = resolveImplicitTag(node.parent.name);\n\t}\n\n\treturn node;\n};\n\nfunction isRoot(node) {\n\treturn !node.parent;\n}\n\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n * @param {Number} from\n * @param {Number} to\n * @returns {Number}\n */\nfunction rand(from, to) {\n\treturn Math.floor(Math.random() * (to - from) + from);\n}\n\n/**\n * @param {Array} arr\n * @param {Number} count\n * @returns {Array}\n */\nfunction sample(arr, count) {\n\tconst len = arr.length;\n\tconst iterations = Math.min(len, count);\n\tconst result = new Set();\n\n\twhile (result.size < iterations) {\n\t\tresult.add(arr[rand(0, len)]);\n\t}\n\n\treturn Array.from(result);\n}\n\nfunction choice(val) {\n\treturn val[rand(0, val.length - 1)];\n}\n\nfunction sentence(words, end) {\n\tif (words.length) {\n\t\twords = [capitalize(words[0])].concat(words.slice(1));\n\t}\n\n\treturn words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\n\nfunction capitalize(word) {\n\treturn word[0].toUpperCase() + word.slice(1);\n}\n\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside <code>words</code> array\n * @param {Array} words\n */\nfunction insertCommas(words) {\n\tif (words.length < 2) {\n\t\treturn words;\n\t}\n\n\twords = words.slice();\n\tconst len = words.length;\n\tconst hasComma = /,$/;\n\tlet totalCommas = 0;\n\n\tif (len > 3 && len <= 6) {\n\t\ttotalCommas = rand(0, 1);\n\t} else if (len > 6 && len <= 12) {\n\t\ttotalCommas = rand(0, 2);\n\t} else {\n\t\ttotalCommas = rand(1, 4);\n\t}\n\n\tfor (let i = 0, pos, word; i < totalCommas; i++) {\n\t\tpos = rand(0, len - 2);\n\t\tif (!hasComma.test(words[pos])) {\n\t\t\twords[pos] += ',';\n\t\t}\n\t}\n\n\treturn words;\n}\n\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param {Object} dict Words dictionary (see `lang/*.json`)\n * @param {Number} wordCount Words count in paragraph\n * @param {Boolean} startWithCommon Should paragraph start with common\n * \"lorem ipsum\" sentence.\n * @returns {String}\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n\tconst result = [];\n\tlet totalWords = 0;\n\tlet words;\n\n\tif (startWithCommon && dict.common) {\n\t\twords = dict.common.slice(0, wordCount);\n\t\ttotalWords += words.length;\n\t\tresult.push(sentence(insertCommas(words), '.'));\n\t}\n\n\twhile (totalWords < wordCount) {\n\t\twords = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n\t\ttotalWords += words.length;\n\t\tresult.push(sentence(insertCommas(words)));\n\t}\n\n\treturn result.join(' ');\n}\n\n/**\n * Check if given node is in repeating context, e.g. node itself or one of its\n * parent is repeated\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isRepeating(node) {\n    while (node.parent) {\n        if (node.repeat && node.repeat.value && node.repeat.value > 1) {\n            return true;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\nexport default index;\n","import Profile from '@emmetio/output-profile';\nimport SnippetsRegistry from '@emmetio/snippets-registry';\nimport parseAbbreviation from '@emmetio/abbreviation';\nimport resolveSnippets from '@emmetio/html-snippets-resolver';\nimport transform from '@emmetio/html-transform';\nimport resolveVariables from '@emmetio/variable-resolver';\nimport format from '@emmetio/markup-formatters';\nimport parseAbbreviation$1 from '@emmetio/css-abbreviation';\nimport resolveSnippets$1 from '@emmetio/css-snippets-resolver';\nimport format$1 from '@emmetio/stylesheet-formatters';\nimport defaultSnippets from '@emmetio/snippets';\nimport lorem from '@emmetio/lorem';\n\n/**\n * Expands given abbreviation into code\n * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation\n * @param  {Object} options\n * @return {String}\n */\nfunction expand$1(abbr, options) {\n\toptions = options || {};\n\n\tif (typeof abbr === 'string') {\n\t\tabbr = parse$1(abbr, options);\n\t}\n\n\treturn format(abbr, options.profile, options.syntax, options.format);\n}\n\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n * @param {String} Abbreviation to parse\n * @param  {Object} options\n * @return {Node}\n */\nfunction parse$1(abbr, options) {\n\treturn parseAbbreviation(abbr)\n\t.use(transform, options.text, options.addons)\n\t.use(resolveSnippets, options.snippets)\n\t.use(resolveVariables, options.variables);\n}\n\n/**\n * Expands given abbreviation into code\n * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation\n * @param  {Object} options\n * @return {String}\n */\nfunction expand$2(abbr, options) {\n\toptions = options || {};\n\n\tif (typeof abbr === 'string') {\n\t\tabbr = parse$2(abbr, options);\n\t}\n\n\treturn format$1(abbr, options.profile, options.syntax, options.format);\n}\n\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n * @param {String|Node} Abbreviation to parse or already parsed abbreviation\n * @param  {Object} options\n * @return {Node}\n */\nfunction parse$2(abbr, options) {\n\tif (typeof abbr === 'string') {\n\t\tabbr = parseAbbreviation$1(abbr);\n\t}\n\n\treturn abbr.use(resolveSnippets$1, options.snippets);\n}\n\nconst reLorem = /^lorem([a-z]*)(\\d*)$/;\n\n/**\n * Constructs a snippets registry, filled with snippets, for given options\n * @param  {String} syntax  Abbreviation syntax\n * @param  {Object|Object[]} snippets Additional snippets\n * @return {SnippetsRegistry}\n */\nvar snippetsRegistryFactory = function(syntax, snippets) {\n\tconst registrySnippets = [defaultSnippets[syntax] || defaultSnippets.html];\n\n\tif (Array.isArray(snippets)) {\n\t\tsnippets.forEach(item => {\n\t\t\t// if array item is a string, treat it as a reference to globally\n\t\t\t// defined snippets\n\t\t\tregistrySnippets.push(typeof item === 'string' ? defaultSnippets[item] : item);\n\t\t});\n\t} else if (typeof snippets === 'object') {\n\t\tregistrySnippets.push(snippets);\n\t}\n\n\tconst registry = new SnippetsRegistry(registrySnippets.filter(Boolean));\n\n\t// for non-stylesheet syntaxes add Lorem Ipsum generator\n\tif (syntax !== 'css') {\n\t\tregistry.get(0).set(reLorem, loremGenerator);\n\t}\n\n\treturn registry;\n};\n\nfunction loremGenerator(node) {\n\tconst options = {};\n\tconst m = node.name.match(reLorem);\n\tif (m[1]) {\n\t\toptions.lang = m[1];\n\t}\n\n\tif (m[2]) {\n\t\toptions.wordCount = +m[2];\n\t}\n\n\treturn lorem(node, options);\n}\n\n/**\n * Default variables used in snippets to insert common values into predefined snippets\n * @type {Object}\n */\nconst defaultVariables = {\n\tlang: 'en',\n\tlocale: 'en-US',\n\tcharset: 'UTF-8'\n};\n\n/**\n * A list of syntaxes that should use Emmet CSS abbreviations:\n * a variations of default abbreivation that holds values right in abbreviation name\n * @type {Set}\n */\nconst stylesheetSyntaxes = new Set(['css', 'sass', 'scss', 'less', 'stylus', 'sss']);\n\nconst defaultOptions = {\n\t/**\n\t * Abbreviation output syntax\n\t * @type {String}\n\t */\n\tsyntax: 'html',\n\n\t/**\n\t * Field/tabstop generator for editor. Most editors support TextMate-style\n\t * fields: ${0} or ${1:item}. So for TextMate-style fields this function\n\t * will look like this:\n\t * @example\n\t * (index, placeholder) => `\\${${index}${placeholder ? ':' + placeholder : ''}}`\n\t *\n\t * @param  {Number} index         Placeholder index. Fields with the same indices\n\t * should be linked\n\t * @param  {String} [placeholder] Field placeholder\n\t * @return {String}\n\t */\n\tfield: (index, placeholder) => placeholder || '',\n\n\t/**\n\t * Insert given text string(s) into expanded abbreviation\n\t * If array of strings is given, the implicitly repeated element (e.g. `li*`)\n\t * will be repeated by the amount of items in array\n\t * @type {String|String[]}\n\t */\n\ttext: null,\n\n\t/**\n\t * Either predefined output profile or options for output profile. Used for\n\t * abbreviation output\n\t * @type {Profile|Object}\n\t */\n\tprofile: null,\n\n\t/**\n\t * Custom variables for variable resolver\n\t * @see @emmetio/variable-resolver\n\t * @type {Object}\n\t */\n\tvariables: {},\n\n\t/**\n\t * Custom predefined snippets for abbreviation. The expanded abbreviation\n\t * will try to match given snippets that may contain custom elements,\n\t * predefined attributes etc.\n\t * May also contain array of items: either snippets (Object) or references\n\t * to default syntax snippets (String; the key in default snippets hash)\n\t * @see @emmetio/snippets\n\t * @type {Object|SnippetsRegistry}\n\t */\n\tsnippets: {},\n\n\t/**\n\t * Hash of additional transformations that should be applied to expanded\n\t * abbreviation, like BEM or JSX. Since these transformations introduce\n\t * side-effect, they are disabled by default and should be enabled by\n\t * providing a transform name as a key and transform options as value:\n\t * @example\n\t * {\n\t *     bem: {element: '--'},\n\t *     jsx: true // no options, just enable transform\n\t * }\n\t * @see @emmetio/html-transform/lib/addons\n\t * @type {Object}\n\t */\n\taddons: null,\n\n\t/**\n\t * Additional options for syntax formatter\n\t * @see @emmetio/markup-formatters\n\t * @type {Object}\n\t */\n\tformat: null\n};\n\n/**\n * Expands given abbreviation into string, formatted according to provided\n * syntax and options\n * @param  {String|Node} abbr        Abbreviation string or parsed abbreviation tree\n * @param  {String|Object} [options] Parsing and formatting options (object) or\n * abbreviation syntax (string)\n * @return {String}\n */\nfunction expand$$1(abbr, options) {\n\toptions = createOptions(options);\n\n\treturn isStylesheet(options.syntax)\n\t\t? expand$2(abbr, options)\n\t\t: expand$1(abbr, options);\n}\n\n/**\n * Parses given abbreviation into AST tree. This tree can be later formatted to\n * string with `expand` function\n * @param  {String} abbr             Abbreviation to parse\n * @param  {String|Object} [options] Parsing and formatting options (object) or\n * abbreviation syntax (string)\n * @return {Node}\n */\nfunction parse$$1(abbr, options) {\n\toptions = createOptions(options);\n\n\treturn isStylesheet(options.syntax)\n\t\t? parse$2(abbr, options)\n\t\t: parse$1(abbr, options);\n}\n\n/**\n * Creates snippets registry for given syntax and additional `snippets`\n * @param  {String} syntax   Snippets syntax, used for retreiving predefined snippets\n * @param  {SnippetsRegistry|Object|Object[]} [snippets] Additional snippets\n * @return {SnippetsRegistry}\n */\nfunction createSnippetsRegistry(syntax, snippets) {\n\treturn snippets instanceof SnippetsRegistry\n\t\t? snippets\n\t\t: snippetsRegistryFactory(isStylesheet(syntax) ? 'css' : syntax, snippets);\n}\n\nfunction createOptions(options) {\n\tif (typeof options === 'string') {\n\t\toptions = { syntax: options };\n\t}\n\n\toptions = Object.assign({}, defaultOptions, options);\n\toptions.format = Object.assign({field: options.field}, options.format);\n\toptions.profile = createProfile(options);\n\toptions.variables = Object.assign({}, defaultVariables, options.variables);\n\toptions.snippets = createSnippetsRegistry(isStylesheet(options.syntax) ? 'css' : options.syntax, options.snippets);\n\n\treturn options;\n}\n\n/**\n * Check if given syntax belongs to stylesheet markup.\n * Emmet uses different abbreviation flavours: one is a default markup syntax,\n * used for HTML, Slim, Pug etc, the other one is used for stylesheets and\n * allows embedded values in abbreviation name\n * @param  {String}  syntax\n * @return {Boolean}\n */\nfunction isStylesheet(syntax) {\n\treturn stylesheetSyntaxes.has(syntax);\n}\n\n/**\n * Creates output profile from given options\n * @param  {Object} options\n * @return {Profile}\n */\nfunction createProfile(options) {\n\treturn options.profile instanceof Profile\n\t\t? options.profile\n\t\t: new Profile(options.profile);\n}\n\nexport { expand$$1 as expand, parse$$1 as parse, createSnippetsRegistry, createOptions, isStylesheet, createProfile };\n","'use babel';\n\n/**\n * Syntaxes known by Emmet. All other syntaxes shoud map to one of these\n * @type {Set}\n */\nconst knownSyntaxes = new Set([\n\t'html', 'xml', 'xsl', 'jsx', 'js', 'pug', 'slim', 'haml',\n\t'css', 'sass', 'scss', 'less', 'sss', 'stylus'\n]);\n\n/**\n * Common context checker for abbreviation auto-activation for\n * stylesheet syntaxes (CSS, SCSS, LESS etc.)\n * @param  {CodeMirror} editor\n * @return {Boolean}\n */\nconst stylesheetAutoActivationContext = (editor, pos) => {\n\tconst tokenType = editor.getTokenTypeAt(pos || editor.getCursor());\n\t// NB may return `property` or `property error` type\n\treturn tokenType && /^property\\b/.test(tokenType);\n};\n\nconst autoActivationContext = {\n\thtml(editor, pos) {\n\t\t// Do not provide automatic abbreviation completion inside HTML tags,\n\t\t// e.g. work only inside plain text token\n\t\treturn editor.getTokenTypeAt(pos || editor.getCursor()) === null;\n\t},\n\n\tcss:  stylesheetAutoActivationContext,\n\tless: stylesheetAutoActivationContext,\n\tsass: stylesheetAutoActivationContext,\n\tscss: stylesheetAutoActivationContext\n};\n\n/**\n * Detect Emmet syntax from given editor’s position.\n * @param {CodeMirror}     editor\n * @param {CodeMirror.Pos} [pos]\n * @return {String}        Returns `null` if Emmet syntax can’t be detected\n */\nexport default function detectSyntax(editor, pos) {\n\tconst mode = editor.getModeAt(pos || editor.getCursor());\n\tconst syntax = mode.name === 'xml' ? 'html' : mode.name;\n\n\tif (isSupported(syntax)) {\n\t\treturn syntax;\n\t}\n\n\t// No supported syntax found, try from Emmet-specific options\n\tconst emmetOpt = editor.getOption('emmet');\n\tif (emmetOpt && isSupported(emmetOpt.syntax)) {\n\t\treturn emmetOpt.syntax;\n\t}\n\n\treturn null;\n}\n\n/**\n * Check if given syntax is supported by Emmet\n * @param  {String}  syntax\n * @return {Boolean}\n */\nexport function isSupported(syntax) {\n\treturn knownSyntaxes.has(syntax);\n}\n\n/**\n * Check if current editor’s context (syntax, scope) allows automatic Emmet\n * abbreviation activation as user types text. If this function returns `false`,\n * it is recommended to not create any Emmet completions when user types text,\n * but insert them when user activated autocomplete popup manually\n * @param  {CodeMirror}  editor\n * @param  {CodeMirror.Pos} [pos]\n * @return {Boolean}\n */\nexport function hasAutoActivateContext(editor, pos) {\n\tconst syntax = detectSyntax(editor, pos);\n\treturn syntax && (!autoActivationContext[syntax] || autoActivationContext[syntax](editor, pos));\n}\n","'use strict';\n\n/**\n * Returns token used for single indentation in given editor\n * @param  {CodeMirror} editor\n * @return {String}\n */\nexport function getIndentation(editor) {\n\tif (!editor.getOption('indentWithTabs')) {\n\t\treturn repeatString(' ', editor.getOption('indentUnit'));\n\t}\n\n\treturn '\\t';\n}\n\n/**\n * Normalizes text according to given CodeMirror instance indentation\n * preferences\n * @param  {String}     text\n * @param  {CodeMirror} editor\n * @param  {String}     [indentation] Applies `indentText()` with given argument,\n *                                    if provided\n * @return {String}\n */\nexport function normalizeText(editor, text, indentation) {\n\tlet lines = splitByLines(text);\n\tconst indent = getIndentation(editor);\n\n\tif (indent !== '\\t') {\n\t\tlines = lines.map(line => line.replace(/^\\t+/,\n\t\t\ttabs => repeatString(indent, tabs.length)));\n\t}\n\n\tif (indentation) {\n\t\tlines = lines.map((line, i) => i ? indentation + line : line);\n\t}\n\n\treturn lines.join('\\n');\n}\n\n/**\n * Indents each line, except first one, in given text\n * @param  {String} text\n * @param  {String} indentation\n * @return {String}\n */\nexport function indentText(text, indentation) {\n\treturn splitByLines(text)\n\t.map((line, i) => i ? indentation + line : line)\n\t.join('\\n');\n}\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]} Lines of text\n */\nexport function splitByLines(text) {\n\treturn Array.isArray(text) ? text : text.split(/\\r\\n|\\r|\\n/g);\n}\n\nexport function repeatString(str, count) {\n\tlet result = '';\n\twhile (0 < count--) {\n\t\tresult += str;\n\t}\n\n\treturn result;\n}\n\n/**\n * Quick and dirty way to remove fields from given string\n * @param  {String} str\n * @return {String}\n */\nexport function removeFields(str) {\n\treturn str.replace(/\\$\\{\\d+(:[^\\}]+)?\\}/g, '');\n}\n\n/**\n * Check if given range contains point\n * @param  {CodeMirror.Range} range\n * @param  {CodeMirror.Pos} pos\n * @param  {Boolean} [exclude] Exclude range and and start\n * @return {Boolean}\n */\nexport function containsPos(range, pos, exclude) {\n\treturn exclude\n\t\t? comparePos(pos, range.from) > 0 && comparePos(pos, range.to) < 0\n\t\t: comparePos(pos, range.from) >= 0 && comparePos(pos, range.to) <= 0;\n}\n\nexport function comparePos(a, b) {\n\treturn a.line - b.line || a.ch - b.ch;\n}\n","'use babel';\n\nimport extract from '@emmetio/extract-abbreviation';\nimport { expand, parse, isStylesheet } from '@emmetio/expand-abbreviation';\nimport detectSyntax from './detect-syntax';\nimport { normalizeText } from './utils';\n\nconst cursorMark = '[[::emmet-cursor::]]';\n\n// NB CodeMirror doesn’t natively supports tabstops\nconst editorField = (index, placeholder = '') => placeholder;\n\n/**\n * Expands given abbreviation for given editor.\n * The editor is used to detect abbreviation syntax and provide\n * tag context for markup abbreviations\n * @param  {String|Node} abbr\n * @param  {CodeMirror}  editor\n * @return {String}\n * @throws Error if abbreviation is invalid\n */\nexport default function expandAbbreviation(abbr, editor, options) {\n\treturn expand(abbr, Object.assign({\n\t\tsyntax: detectSyntax(editor),\n\t\tfield: editorField\n\t}, getExpandOptions(editor), options));\n}\n\n/**\n * Parses abbreviation for given editor\n * @param  {String} abbr\n * @param  {CodeMirror} editor\n * @return {Node}\n * @throws Error if abbreviation is invalid\n */\nexport function parseAbbreviation(abbr, editor) {\n\treturn parse(abbr, Object.assign({\n\t\tsyntax: detectSyntax(editor),\n\t}, getExpandOptions(editor)));\n}\n\n/**\n * Extracts abbreviation from given position of editor\n * @param  {CodeMirror}     editor\n * @param  {CodeMirror.Pos} [pos]\n * @return {Object}         Object with `{abbreviation, location}` properties or `null`\n */\nexport function extractAbbreviation(editor, pos) {\n\tpos = pos || pos.getCursor();\n\tconst line = editor.getLine(pos.line);\n\n\treturn extract(line, pos.ch, true);\n}\n\n/**\n * Returns abbreviation model: object with `ast` and `snippet` properties\n * that contains parsed and expanded abbreviation respectively\n * @param  {String} abbreviation\n * @param  {CodeMirror} editor\n * @return {Object} Returns `null` if abbreviation cannot be parsed\n */\nexport function createAbbreviationModel(abbreviation, editor) {\n\ttry {\n\t\tconst ast = parseAbbreviation(abbreviation, editor);\n\t\treturn {\n\t\t\tast,\n\t\t\tabbreviation,\n\t\t\tsnippet: expandAbbreviation(abbreviation, editor)\n\t\t};\n\t} catch (err) {\n\t\t// console.warn('Unable to build Emmet abbreviation model', err);\n\t\treturn null;\n\t}\n}\n\n/**\n * Expands given abbreviation and inserts expanded result into editor, maintaining\n * proper indentation and final cursor position\n * @param  {CodeMirror} editor CodeMirror editor instance\n * @param  {String|Object} abbr  Abbreviation to expand (string or parsed)\n * @param  {CodeMirror.Range} range Location of abbreviation in editor\n * @return {Boolean} Returns `true` if abbreviation was successfully expanded and inserted\n */\nexport function expandAndInsert(editor, abbr, range) {\n\tlet cursorMarked = false;\n\tlet newSelectionSize = 0;\n\tlet expanded;\n\n\ttry {\n\t\texpanded = expandAbbreviation(abbr, editor, {\n\t\t\t// CodeMirror doesn’t support snippets with tab-stops natively so we have\n\t\t\t// to mark first output with a special token so we can find it later\n\t\t\t// to properly plant cursor into new position\n\t\t\tfield(index, placeholder = '') {\n\t\t\t\tif (!cursorMarked) {\n\t\t\t\t\tcursorMarked = true;\n\t\t\t\t\tnewSelectionSize = placeholder.length;\n\t\t\t\t\tplaceholder = cursorMark + placeholder;\n\t\t\t\t}\n\n\t\t\t\treturn placeholder;\n\t\t\t}\n\t\t});\n\t} catch (err) {\n\t\t// Invalid abbreviation\n\t\t// console.warn(err);\n\t\treturn false;\n\t}\n\n\tconst line = editor.getLine(range.from.line);\n\tconst matchIndent = line.match(/^\\s+/);\n\texpanded = normalizeText(editor, expanded, matchIndent && matchIndent[0]);\n\n\tlet newCursorPos = expanded.length;\n\n\tif (cursorMarked) {\n\t\t// Remove cursor stub and re-position cursor\n\t\tnewCursorPos = expanded.indexOf(cursorMark);\n\t\texpanded = expanded.slice(0, newCursorPos) + expanded.slice(newCursorPos + cursorMark.length);\n\t}\n\n\t// Replace abbreviation with expanded result\n\treturn editor.operation(() => {\n\t\teditor.replaceRange(expanded, range.from, range.to);\n\n\t\t// Position cursor\n\t\tconst startIx = editor.indexFromPos(range.from);\n\t\tconst newCursor = editor.posFromIndex(newCursorPos + startIx);\n\t\tif (newSelectionSize) {\n\t\t\teditor.setSelection(newCursor, {\n\t\t\t\tline: newCursor.line,\n\t\t\t\tch: newCursor.ch + newSelectionSize\n\t\t\t});\n\t\t} else {\n\t\t\teditor.setCursor(newCursor);\n\t\t}\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Returns options object for syntax from given editor. In most cases, it detects\n * XML-style syntax (HTML, XML, XHTML) and returns options configured for proper\n * output\n * @param  {CodeMirror} editor\n * @param  {Point}      [pos]  Point in editor where syntax should be detected.\n *                             Uses `editor.getCursor()` in not given\n * @return {Object}\n */\nexport function getExpandOptions(editor, pos) {\n\tconst mode = editor.getModeAt(pos || editor.getCursor());\n\tconst emmetOpt = editor.getOption('emmet');\n\tlet profile = emmetOpt && emmetOpt.profile;\n\n\tif (mode.name === 'xml') {\n\t\tprofile = Object.assign({ selfClosingStyle: mode.configuration }, profile);\n\t}\n\n\treturn Object.assign({\n\t\tprofile,\n\t\tsnippets: snippetsFromOptions(editor, detectSyntax(editor, pos))\n\t}, emmetOpt);\n}\n\n/**\n * Returns custom snippets from Emmet options of given editor\n * @param  {CodeMirror} editor\n * @param  {String} syntax\n * @return {Object}\n */\nexport function snippetsFromOptions(editor, syntax) {\n\tconst emmetOpt = editor.getOption('emmet');\n\tif (emmetOpt) {\n\t\treturn isStylesheet(syntax)\n\t\t\t? emmetOpt.stylesheetSnippets\n\t\t\t: emmetOpt.markupSnippets;\n\t}\n}\n","'use strict';\n\nimport { createAbbreviationModel, extractAbbreviation } from './expand-abbreviation';\nimport { hasAutoActivateContext } from './detect-syntax';\n\nconst emmetMarkerClass = 'emmet-abbreviation';\n\n/**\n * Editor’s `change` event handler that marks Emmet abbreviation when editor\n * content is updated\n * @param  {CodeMirror} editor\n */\nexport function markOnEditorChange(editor) {\n\tconst marker = findMarker(editor, editor.getCursor());\n\tif (marker && isValidMarker(editor, marker)) {\n\t\treturn;\n\t}\n\n\t// No valid marker under caret, remove all registered markers\n\t// and create a new one\n\tclearMarkers(editor);\n\tif (hasAutoActivateContext(editor)) {\n\t\tmarkAbbreviation(editor, editor.getCursor());\n\t}\n}\n\n/**\n * Returns *valid* Emmet abbreviation marker (if any) for given position of editor\n * @param  {CodeMirror}     editor\n * @param  {CodeMirror.Pos} [pos]\n * @return {CodeMirror.TextMarker}\n */\nexport function findMarker(editor, pos) {\n\tconst markers = editor.findMarksAt(pos);\n\tfor (let i = 0; i < markers.length; i++) {\n\t\tif (markers[i].className === emmetMarkerClass) {\n\t\t\treturn markers[i];\n\t\t}\n\t}\n}\n\n/**\n * Marks Emmet abbreviation for given editor position, if possible\n * @param  {TextEditor} editor   Editor where abbreviation marker should be created\n * @param  {Point}      pos      Buffer position where abbreviation should be created.\n *                               Abbreviation will be automatically extracted from\n *                               given position\n * @param  {Boolean}    [forced] Indicates that user forcibly requested abbreviation\n *                               marker (e.g. was not activated automatically).\n *                               Affects abbreviation detection policy\n * @return {DisplayMarker} Returns `undefined` if no valid abbreviation under caret\n */\nexport function markAbbreviation(editor, pos, forced) {\n\tconst marker = findMarker(editor, pos);\n\tif (marker) {\n\t\t// there’s active marker with valid abbreviation\n\t\treturn marker;\n\t}\n\n\t// No active marker: remove previous markers and create new one, if possible\n\tclearMarkers(editor);\n\n\tconst extracted = extractAbbreviation(editor, pos);\n\tconst model = extracted && createAbbreviationModel(extracted.abbreviation, editor);\n\n\tif (model && (forced || allowedForAutoActivation(model))) {\n\t\tconst from = { line: pos.line, ch: extracted.location };\n\t\tconst to = { line: pos.line, ch: extracted.location + extracted.abbreviation.length };\n\n\t\tconst marker = editor.markText(from, to, {\n\t\t\tinclusiveRight: true,\n\t\t\tclearWhenEmpty: true,\n\t\t\tclassName: emmetMarkerClass\n\t\t});\n\t\tmarker.model = model;\n\t\treturn marker;\n\t}\n}\n\n/**\n * Removes Emmmet abbreviation markers from given editor\n * @param  {TextEditor} editor\n */\nexport function clearMarkers(editor) {\n\tconst markers = editor.getAllMarks();\n\tfor (let i = 0; i < markers.length; i++) {\n\t\tif (markers[i].className === emmetMarkerClass) {\n\t\t\tmarkers[i].clear();\n\t\t}\n\t}\n}\n\n/**\n * Check if given abbreviation model is allowed for auto-activated abbreviation\n * marker. Used to reduce falsy activations\n * @param  {Object} model Parsed abbreviation model (see `createAbbreviationModel()`)\n * @return {Boolean}\n */\nfunction allowedForAutoActivation(model) {\n\tconst rootNode = model.ast.children[0];\n\t// The very first node should start with alpha character\n\t// Skips falsy activations for something like `$foo` etc.\n\treturn rootNode && /^[a-z]/i.test(rootNode.name);\n}\n\n/**\n * Ensures that given editor Emmet abbreviation marker contains valid Emmet abbreviation\n * and updates abbreviation model if required\n * @param {CodeMirror} editor\n * @param {CodeMirror.TextMarket} marker\n * @return {Boolean} `true` if marker contains valid abbreviation\n */\nfunction isValidMarker(editor, marker) {\n\tconst range = marker.find();\n\n\t// No newlines inside abreviation\n\tif (range.from.line !== range.to.line) {\n\t\treturn false;\n\t}\n\n\t// Make sure marker contains valid abbreviation\n\tconst text = editor.getRange(range.from, range.to);\n\tif (!text || /^\\s|\\s$/g.test(text)) {\n\t\treturn false;\n\t}\n\n\tif (!marker.model || marker.model.abbreviation !== text) {\n\t\t// marker contents was updated, re-parse abbreviation\n\t\tmarker.model = createAbbreviationModel(text, editor);\n\t}\n\n\treturn !!(marker.model && marker.model.snippet);\n}\n","const DASH = 45; // -\n\n/**\n * Calculates fuzzy match score of how close `abbr` matches given `string`.\n * @param  {String} abbr        Abbreviation to score\n * @param  {String} string      String to match\n * @param  {Number} [fuzziness] Fuzzy factor\n * @return {Number}             Match score\n */\nvar stringScore = function(abbr, string) {\n    if (abbr === string) {\n        return 1;\n    }\n\n    // a string MUST start with the same character as abbreviation\n    if (!string || abbr.charCodeAt(0) !== string.charCodeAt(0)) {\n        return 0;\n    }\n\n    const abbrLength = abbr.length;\n    const stringLength = string.length;\n    let i = 1, j = 1, score = stringLength;\n    let ch1, ch2, found, acronym;\n\n    while (i < abbrLength) {\n        ch1 = abbr.charCodeAt(i);\n        found = false;\n        acronym = false;\n\n        while (j < stringLength) {\n            ch2 = string.charCodeAt(j);\n\n            if (ch1 === ch2) {\n                found = true;\n                score += (stringLength - j) * (acronym ? 2 : 1);\n                break;\n            }\n\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === DASH;\n            j++;\n        }\n\n        if (!found) {\n            break;\n        }\n\n        i++;\n    }\n\n    return score && score * (i / abbrLength) / sum(stringLength);\n};\n\n/**\n * Calculates sum of first `n` natural numbers, e.g. 1+2+3+...n\n * @param  {Number} n\n * @return {Number}\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nconst reProperty = /^([a-z\\-]+)(?:\\s*:\\s*([^\\n\\r]+))?$/;\nconst DASH$1 = 45; // -\n\n/**\n * Creates a special structure for resolving CSS properties from plain CSS\n * snippets.\n * Almost all CSS snippets are aliases for real CSS properties with available\n * value variants, optionally separated by `|`. Most values are keywords that\n * can be fuzzy-resolved as well. Some CSS properties are shorthands for other,\n * more specific properties, like `border` and `border-style`. For such cases\n * keywords from more specific properties should be available in shorthands too.\n * @param {Snippet[]} snippets\n * @return {CSSSnippet[]}\n */\nvar cssSnippets = function(snippets) {\n    return nest( snippets.map(snippet => new CSSSnippet(snippet.key, snippet.value)) );\n};\n\nclass CSSSnippet {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.property = null;\n\n        // detect if given snippet is a property\n        const m = value && value.match(reProperty);\n        if (m) {\n            this.property = m[1];\n            this.value = m[2];\n        }\n\n        this.dependencies = [];\n    }\n\n    addDependency(dep) {\n        this.dependencies.push(dep);\n    }\n\n    get defaulValue() {\n        return this.value != null ? splitValue(this.value)[0] : null;\n    }\n\n    /**\n     * Returns list of unique keywords for current CSS snippet and its dependencies\n     * @return {String[]}\n     */\n    keywords() {\n        const stack = [];\n        const keywords = new Set();\n        let i = 0, item, candidates;\n\n        if (this.property) {\n            // scan valid CSS-properties only\n            stack.push(this);\n        }\n\n        while (i < stack.length) {\n            // NB Keep items in stack instead of push/pop to avoid possible\n            // circular references\n            item = stack[i++];\n\n            if (item.value) {\n                candidates = splitValue(item.value).filter(isKeyword$1);\n\n                // extract possible keywords from snippet value\n                for (let j = 0; j < candidates.length; j++) {\n                    keywords.add(candidates[j].trim());\n                }\n\n                // add dependencies into scan stack\n                for (let j = 0, deps = item.dependencies; j < deps.length; j++) {\n                    if (stack.indexOf(deps[j]) === -1) {\n                        stack.push(deps[j]);\n                    }\n                }\n            }\n        }\n\n        return Array.from(keywords);\n    }\n}\n\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * background-position-x -> background-position -> background\n * @param  {CSSSnippet[]} snippets\n * @return {CSSSnippet[]}\n */\nfunction nest(snippets) {\n    snippets = snippets.sort(snippetsSort);\n    const stack = [];\n\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // backgound -> background-position -> background-position-x\n    for (let i = 0, cur, prev; i < snippets.length; i++) {\n        cur = snippets[i];\n\n        if (!cur.property) {\n            // not a CSS property, skip it\n            continue;\n        }\n\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n\n            if (cur.property.indexOf(prev.property) === 0\n                && cur.property.charCodeAt(prev.property.length) === DASH$1) {\n                prev.addDependency(cur);\n                stack.push(cur);\n                break;\n            }\n\n            stack.pop();\n        }\n\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n\n    return snippets;\n}\n\n/**\n * A sorting function for array of snippets\n * @param  {CSSSnippet} a\n * @param  {CSSSnippet} b\n * @return {Number}\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n\n    return a.key < b.key ? -1 : 1;\n}\n\n/**\n * Check if given string is a keyword candidate\n * @param  {String}  str\n * @return {Boolean}\n */\nfunction isKeyword$1(str) {\n    return /^\\s*[\\w\\-]+/.test(str);\n}\n\nfunction splitValue(value) {\n    return String(value).split('|');\n}\n\nconst globalKeywords = ['auto', 'inherit', 'unset'];\nconst unitlessProperties = [\n    'z-index', 'line-height', 'opacity', 'font-weight', 'zoom',\n    'flex', 'flex-grow', 'flex-shrink'\n];\nconst unitAliases = {\n    e :'em',\n    p: '%',\n    x: 'ex',\n    r: 'rem'\n};\n\n/**\n * For every node in given `tree`, finds matching snippet from `registry` and\n * updates node with snippet data.\n *\n * This resolver uses fuzzy matching for searching matched snippets and their\n * keyword values.\n */\n\nvar index = function(tree, registry) {\n\tconst snippets = convertToCSSSnippets(registry);\n\ttree.walk(node => resolveNode(node, snippets));\n\treturn tree;\n};\n\nfunction convertToCSSSnippets(registry) {\n    return cssSnippets(registry.all({type: 'string'}))\n}\n\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n * @param  {Node} node\n * @param  {CSSSnippet[]} snippets\n * @return {Node}\n */\nfunction resolveNode(node, snippets) {\n\tconst snippet = findBestMatch(node.name, snippets, 'key');\n\n\tif (!snippet) {\n\t\t// Edge case: `!important` snippet\n\t\treturn node.name === '!' ? setNodeAsText(node, '!important') : node;\n\t}\n\n\treturn snippet.property\n\t\t? resolveAsProperty(node, snippet)\n\t\t: resolveAsSnippet(node, snippet);\n}\n\n/**\n * Resolves given parsed abbreviation node as CSS propery\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @return {Node}\n */\nfunction resolveAsProperty(node, snippet) {\n    const abbr = node.name;\n\tnode.name = snippet.property;\n\n\tif (node.value && typeof node.value === 'object') {\n\t\t// resolve keyword shortcuts\n\t\tconst keywords = snippet.keywords();\n\n\t\tif (!node.value.size) {\n\t\t\t// no value defined, try to resolve unmatched part as a keyword alias\n\t\t\tlet kw = findBestMatch(getUnmatchedPart(abbr, snippet.key), keywords);\n\n            if (!kw) {\n                // no matching value, try to get default one\n                kw = snippet.defaulValue;\n                if (kw && kw.indexOf('${') === -1) {\n                    // Quick and dirty test for existing field. If not, wrap\n                    // default value in a field\n                    kw = `\\${1:${kw}}`;\n                }\n            }\n\n\t\t\tif (kw) {\n\t\t\t\tnode.value.add(kw);\n\t\t\t}\n\t\t} else {\n\t\t\t// replace keyword aliases in current node value\n\t\t\tfor (let i = 0, token; i < node.value.value.length; i++) {\n\t\t\t\ttoken = node.value.value[i];\n\n\t\t\t\tif (token === '!') {\n\t\t\t\t\ttoken = `${!i ? '${1} ' : ''}!important`;\n\t\t\t\t} else if (isKeyword(token)) {\n\t\t\t\t\ttoken = findBestMatch(token.value, keywords)\n\t\t\t\t\t\t|| findBestMatch(token.value, globalKeywords)\n\t\t\t\t\t\t|| token;\n\t\t\t\t} else if (isNumericValue(token)) {\n                    token = resolveNumericValue(node.name, token);\n                }\n\n                node.value.value[i] = token;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node;\n}\n\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @return {Node}\n */\nfunction resolveAsSnippet(node, snippet) {\n\treturn setNodeAsText(node, snippet.value);\n}\n\n/**\n * Sets given parsed abbreviation node as a text snippet\n * @param {Node} node\n * @param {String} text\n * @return {Node}\n */\nfunction setNodeAsText(node, text) {\n\tnode.name = null;\n\tnode.value = text;\n\treturn node;\n}\n\n/**\n * Finds best matching item from `items` array\n * @param {String} abbr  Abbreviation to match\n * @param {Array}  items List of items for match\n * @param {String} [key] If `items` is a list of objects, use `key` as object\n * property to test against\n * @return {*}\n */\nfunction findBestMatch(abbr, items, key) {\n\tif (!abbr) {\n\t\treturn null;\n\t}\n\n\tlet matchedItem = null;\n\tlet maxScore = 0;\n\n\tfor (let i = 0, item; i < items.length; i++) {\n\t\titem = items[i];\n\t\tconst score = stringScore(abbr, getScoringPart(item, key));\n\n\t\tif (score === 1) {\n\t\t\t// direct hit, no need to look further\n\t\t\treturn item;\n\t\t}\n\n\t\tif (score && score >= maxScore) {\n\t\t\tmaxScore = score;\n\t\t\tmatchedItem = item;\n\t\t}\n\t}\n\n\treturn matchedItem;\n}\n\nfunction getScoringPart(item, key) {\n    const value = item && typeof item === 'object' ? item[key] : item;\n    const m = (value || '').match(/^[\\w-@]+/);\n    return m ? m[0] : value;\n}\n\n/**\n * Returns a part of `abbr` that wasn’t directly matched agains `string`.\n * For example, if abbreviation `poas` is matched against `position`, the unmatched part will be `as`\n * since `a` wasn’t found in string stream\n * @param {String} abbr\n * @param {String} string\n * @return {String}\n */\nfunction getUnmatchedPart(abbr, string) {\n\tfor (let i = 0, lastPos = 0; i < abbr.length; i++) {\n\t\tlastPos = string.indexOf(abbr[i], lastPos);\n\t\tif (lastPos === -1) {\n\t\t\treturn abbr.slice(i);\n\t\t}\n        lastPos++;\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if given CSS value token is a keyword\n * @param {*} token\n * @return {Boolean}\n */\nfunction isKeyword(token) {\n\treturn tokenTypeOf(token, 'keyword');\n}\n\n/**\n * Check if given CSS value token is a numeric value\n * @param  {*}  token\n * @return {Boolean}\n */\nfunction isNumericValue(token) {\n    return tokenTypeOf(token, 'numeric');\n}\n\nfunction tokenTypeOf(token, type) {\n\treturn token && typeof token === 'object' && token.type === type;\n}\n\n/**\n * Resolves numeric value for given CSS property\n * @param  {String} property    CSS property name\n * @param  {NumericValue} token CSS numeric value token\n * @return {NumericValue}\n */\nfunction resolveNumericValue(property, token) {\n    if (token.unit) {\n        token.unit = unitAliases[token.unit] || token.unit;\n    } else if (token.value !== 0 && unitlessProperties.indexOf(property) === -1) {\n        // use `px` for integers, `em` for floats\n        // NB: num|0 is a quick alternative to Math.round(0)\n        token.unit = token.value === (token.value|0) ? 'px' : 'em';\n    }\n\n    return token;\n}\n\nexport { convertToCSSSnippets, stringScore, cssSnippets };export default index;\n","'use strict';\n\nimport { createSnippetsRegistry, isStylesheet } from '@emmetio/expand-abbreviation';\nimport { convertToCSSSnippets } from '@emmetio/css-snippets-resolver';\nimport detectSyntax from './detect-syntax';\nimport expandAbbreviation, { expandAndInsert, snippetsFromOptions } from './expand-abbreviation';\nimport { removeFields } from './utils';\n\n/**\n * Returns available completions from given editor\n * @param  {CodeMirror}      editor\n * @param  {String}          abbrModel   Parsed Emmet abbreviation model for which\n *                                       completions should be populated\n *                                       (see `createAbbreviationModel()`)\n * @param  {CodeMirror.Pos}  abbrPos     Abbreviation location in editor\n * @param  {CodeMirror.Pos}  [cursorPos] Cursor position in editor\n * @return {EmmetCompletion[]}\n */\nexport default function(editor, abbrModel, abbrPos, cursorPos) {\n\tcursorPos = cursorPos || editor.getCursor();\n\tconst syntax = detectSyntax(editor, cursorPos);\n\tif (!syntax) {\n\t\t// Unsupported syntax\n\t\treturn [];\n\t}\n\n\treturn isStylesheet(syntax)\n\t\t? getStylesheetCompletions(editor, abbrModel, abbrPos, cursorPos)\n\t\t: getMarkupCompletions(editor, abbrModel, abbrPos, cursorPos);\n}\n\n/**\n * Returns completions for markup syntaxes (HTML, Slim, Pug etc.)\n * @param  {CodeMirror}      editor\n * @param  {Object}          abbrModel   Parsed Emmet abbreviation model for which\n *                                       completions should be populated\n *                                       (see `createAbbreviationModel()`)\n * @param  {CodeMirror.Pos}  abbrPos     Abbreviation location in editor\n * @param  {CodeMirror.Pos}  [cursorPos] Cursor position in editor\n * @return {EmmetCompletion[]}\n */\nexport function getMarkupCompletions(editor, abbrModel, abbrPos, cursorPos) {\n\tlet result = [];\n\tcursorPos = cursorPos || editor.getCursor();\n\n\tconst abbrRange = {\n\t\tfrom: abbrPos,\n\t\tto: { line: abbrPos.line, ch: abbrPos.ch + abbrModel.abbreviation.length }\n\t};\n\n\tresult.push(new EmmetCompletion('expanded-abbreviation', editor, abbrRange, 'Expand abbreviation',\n\t\tabbrModel.snippet, () => expandAndInsert(editor, abbrModel.abbreviation, abbrRange)));\n\n\t// Make sure that current position precedes element name (e.g. not attribute,\n\t// class, id etc.)\n\tconst prefix = getMarkupPrefix(abbrModel.abbreviation, cursorPos.ch - abbrPos.ch);\n\tif (prefix !== null) {\n\t\tconst prefixRange = {\n\t\t\tfrom: { line: cursorPos.line, ch: cursorPos.ch - prefix.length },\n\t\t\tto: cursorPos\n\t\t};\n\n\t\tconst completions = getSnippetCompletions(editor, cursorPos)\n\t\t.filter(snippet => snippet.key !== prefix && snippet.key.indexOf(prefix) === 0)\n\t\t.map(snippet => new EmmetCompletion('snippet', editor, prefixRange, snippet.key,\n\t\t\tsnippet.preview, snippet.key));\n\n\t\tresult = result.concat(completions);\n\t}\n\n\treturn result;\n}\n\n/**\n * Returns completions for stylesheet syntaxes\n * @param  {CodeMirror} editor\n * @param  {Object} abbrModel\n * @param  {CodeMirror.Pos} abbrPos\n * @param  {CodeMirror.Pos} cursorPos\n * @return {EmmetCompletion[]}\n */\nfunction getStylesheetCompletions(editor, abbrModel, abbrPos, cursorPos) {\n\tlet result = [];\n\tcursorPos = cursorPos || editor.getCursor();\n\n\tconst abbrRange = {\n\t\tfrom: abbrPos,\n\t\tto: { line: abbrPos.line, ch: abbrPos.ch + abbrModel.abbreviation.length }\n\t};\n\n\tresult.push(new EmmetCompletion('expanded-abbreviation', editor, abbrRange, 'Expand abbreviation',\n\t\tabbrModel.snippet, () => expandAndInsert(editor, abbrModel.abbreviation, abbrRange)));\n\n\t// Make sure that current position precedes element name (e.g. not attribute,\n\t// class, id etc.)\n\tconst prefix = getStylesheetPrefix(abbrModel.abbreviation, cursorPos.ch - abbrPos.ch);\n\tif (prefix !== null) {\n\t\tconst prefixRange = {\n\t\t\tfrom: { line: cursorPos.line, ch: cursorPos.ch - prefix.length },\n\t\t\tto: cursorPos\n\t\t};\n\n\t\tconst completions = getSnippetCompletions(editor, cursorPos)\n\t\t.filter(snippet => snippet.key !== prefix && snippet.key.indexOf(prefix) === 0)\n\t\t.map(snippet => new EmmetCompletion('snippet', editor, prefixRange,\n\t\t\tsnippet.key, snippet.preview, snippet.key));\n\n\t\tresult = result.concat(completions);\n\t}\n\n\treturn result;\n}\n\n/**\n * Returns all possible snippets completions for given editor context.\n * Completions are cached in editor for for re-use\n * @param  {CodeMirror} editor\n * @param  {CodeMirror.Pos} pos\n * @return {Array}\n */\nfunction getSnippetCompletions(editor, pos) {\n\tconst syntax = detectSyntax(editor, pos);\n\n\tif (!editor.state.emmetCompletions) {\n\t\teditor.state.emmetCompletions = {};\n\t}\n\n\tconst cache = editor.state.emmetCompletions;\n\n\tif (!(syntax in cache)) {\n\t\tconst registry = createSnippetsRegistry(syntax, snippetsFromOptions(editor, syntax));\n\n\t\tif (isStylesheet(syntax)) {\n\t\t\t// Collect snippets for stylesheet context: just a plain list of\n\t\t\t// snippets, converted specifically for CSS context\n\t\t\tcache[syntax] = convertToCSSSnippets(registry).map(snippet => {\n\t\t\t\tlet preview = snippet.property;\n\t\t\t\tconst keywords = snippet.keywords();\n\t\t\t\tif (keywords.length) {\n\t\t\t\t\tpreview += `: ${removeFields(keywords.join(' | '))}`;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tkey: snippet.key,\n\t\t\t\t\tvalue: snippet.value,\n\t\t\t\t\tkeywords,\n\t\t\t\t\tpreview\n\t\t\t\t};\n\t\t\t});\n\t\t} else {\n\t\t\t// Collect snippets for markup syntaxes: HTML, XML, Slim, Pug etc.\n\t\t\t// Not just a plain snippets list but thier expanded result as well\n\t\t\tconst field = (index, placeholder) => placeholder || '';\n\t\t\tconst expandOpt = { syntax, field };\n\n\t\t\tcache[syntax] = registry.all({type: 'string'}).map(snippet => ({\n\t\t\t\tkey: snippet.key,\n\t\t\t\tvalue: snippet.value,\n\t\t\t\tpreview: expandAbbreviation(snippet.value, editor, expandOpt)\n\t\t\t}));\n\t\t}\n\t}\n\n\treturn cache[syntax];\n}\n\n/**\n * Returns node element prefix, if applicable, for given `pos` in abbreviation\n * for markup syntaxes completions\n * @param  {String} abbr\n * @param  {Number} pos\n * @return {String} Returns `null` if not in element name context\n */\nfunction getMarkupPrefix(abbr, pos) {\n\treturn getPrefix(abbr, pos, /[\\w:\\-\\$@]+$/);\n}\n\n/**\n * Returns node element prefix, if applicable, for given `pos` in abbreviation\n * for stylesheet syntaxes completions\n * @param  {String} abbr\n * @param  {Number} pos\n * @return {String} Returns `null` if not in element name context\n */\nfunction getStylesheetPrefix(abbr, pos) {\n\treturn getPrefix(abbr, pos, /[\\w-@$]+$/);\n}\n\n/**\n * Get snippet completion prefix that matches given `match` regexp from `pos`\n * character pasition of given `abbr` abbreviation\n * @param  {String} abbr\n * @param  {Number} pos\n * @param  {RegExp} match\n * @return {String}\n */\nfunction getPrefix(abbr, pos, match) {\n\tif (pos === 0) {\n\t\t// Word prefix is at the beginning of abbreviation: it’s an element\n\t\t// context for sure\n\t\treturn '';\n\t}\n\n\tconst m = abbr.slice(0, pos).match(match);\n\tconst prefix = m && m[0] || '';\n\n\t// Check if matched prefix is either at the beginning of abbreviation or\n\t// at the element bound, e.g. right after operator\n\tif (prefix && (prefix === abbr || /[>\\^\\+\\(\\)]/.test(abbr[pos - prefix.length - 1]))) {\n\t\treturn prefix;\n\t}\n\n\treturn null;\n}\n\nclass EmmetCompletion {\n\tconstructor(type, editor, range, label, preview, snippet) {\n\t\tthis.type = type;\n\t\tthis.editor = editor;\n\t\tthis.range = range;\n\t\tthis.label = label;\n\t\tthis.preview = preview;\n\t\tthis.snippet = snippet;\n\n\t\tthis._inserted = false;\n\t}\n\n\tinsert() {\n\t\tif (!this._inserted) {\n\t\t\tthis._inserted = true;\n\t\t\tif (typeof this.snippet === 'function') {\n\t\t\t\tthis.snippet(this.editor, this.range);\n\t\t\t} else {\n\t\t\t\tthis.editor.replaceRange(this.snippet, this.range.from, this.range.to);\n\n\t\t\t\t// Position cursor\n\t\t\t\tconst startIx = this.editor.indexFromPos(this.range.from);\n\t\t\t\tconst newCursor = this.editor.posFromIndex(startIx + this.snippet.length);\n\t\t\t\tthis.editor.setCursor(newCursor);\n\t\t\t}\n\t\t}\n\t}\n};\n","/**\n * Methods for consuming quoted values\n */\n\nconst SINGLE_QUOTE = 39; // '\nconst DOUBLE_QUOTE = 34; // \"\n\nconst defaultOptions = {\n\tescape: 92,   // \\ character\n\tthrows: false\n};\n\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @param  {StreamReader} stream\n * @param  {Number}  options.escape A character code of quote-escape symbol\n * @param  {Boolean} options.throws Throw error if quotes string can’t be properly consumed\n * @return {Boolean} `true` if quoted string was consumed. The contents\n *                   of quoted string will be availabe as `stream.current()`\n */\nvar eatQuoted = function(stream, options) {\n\toptions = options ? Object.assign({}, defaultOptions, options) : defaultOptions;\n\tconst start = stream.pos;\n\tconst quote = stream.peek();\n\n\tif (stream.eat(isQuote)) {\n\t\twhile (!stream.eof()) {\n\t\t\tswitch (stream.next()) {\n\t\t\t\tcase quote:\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn true;\n\n\t\t\t\tcase options.escape:\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then stream wasn’t properly consumed.\n\t\t// Revert stream and decide what to do\n\t\tstream.pos = start;\n\n\t\tif (options.throws) {\n\t\t\tthrow stream.error('Unable to consume quoted string');\n\t\t}\n\t}\n\n\treturn false;\n};\n\nfunction isQuote(code) {\n\treturn code === SINGLE_QUOTE || code === DOUBLE_QUOTE;\n}\n\n/**\n * Check if given code is a number\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isNumber(code) {\n\treturn code > 47 && code < 58;\n}\n\n/**\n * Check if given character code is alpha code (letter through A to Z)\n * @param  {Number}  code\n * @param  {Number}  [from]\n * @param  {Number}  [to]\n * @return {Boolean}\n */\nfunction isAlpha(code, from, to) {\n\tfrom = from || 65; // A\n\tto   = to   || 90; // Z\n\tcode &= ~32; // quick hack to convert any char code to uppercase char code\n\n\treturn code >= from && code <= to;\n}\n\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaNumeric(code) {\n\treturn isNumber(code) || isAlpha(code);\n}\n\nfunction isWhiteSpace(code) {\n\treturn code === 32   /* space */\n\t\t|| code === 9    /* tab */\n\t\t|| code === 160; /* non-breaking space */\n}\n\n/**\n * Check if given character code is a space\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isSpace(code) {\n\treturn isWhiteSpace(code)\n\t\t|| code === 10  /* LF */\n\t\t|| code === 13; /* CR */\n}\n\nconst defaultOptions$1 = {\n\tescape: 92,   // \\ character\n\tthrows: false\n};\n\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param  {StreamReader} stream\n * @param  {Number} open      Character code of pair openinig\n * @param  {Number} close     Character code of pair closing\n * @param  {Object} [options]\n * @return {Boolean}       Returns `true` if chacarter pair was successfully\n *                         consumed, it’s content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n\toptions = options ? Object.assign({}, defaultOptions$1, options) : defaultOptions$1;\n\tconst start = stream.pos;\n\n\tif (stream.eat(open)) {\n\t\tlet stack = 1, ch;\n\n\t\twhile (!stream.eof()) {\n\t\t\tif (eatQuoted(stream, options)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tch = stream.next();\n\t\t\tif (ch === open) {\n\t\t\t\tstack++;\n\t\t\t} else if (ch === close) {\n\t\t\t\tstack--;\n\t\t\t\tif (!stack) {\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (ch === options.escape) {\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\n\t\t// If we’re here then paired character can’t be consumed\n\t\tstream.pos = start;\n\n\t\tif (options.throws) {\n\t\t\tthrow stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport { eatQuoted, isQuote, isAlpha, isNumber, isAlphaNumeric, isSpace, isWhiteSpace, eatPair };\n","import StreamReader from '@emmetio/stream-reader';\nimport { eatPair, eatQuoted, isAlphaNumeric, isQuote, isSpace } from '@emmetio/stream-reader-utils';\n\nclass Node {\n\tconstructor(stream, type, open, close) {\n\t\tthis.stream = stream;\n\t\tthis.type = type;\n\t\tthis.open = open;\n\t\tthis.close = close;\n\n\t\tthis.children = [];\n\t\tthis.parent = null;\n\t}\n\n\t/**\n\t * Returns node name\n\t * @return {String}\n\t */\n\tget name() {\n\t\tif (this.type === 'tag' && this.open) {\n\t\t\treturn this.open && this.open.name && this.open.name.value;\n\t\t}\n\n\t\treturn '#' + this.type;\n\t}\n\n\t/**\n\t * Returns attributes of current node\n\t * @return {Array}\n\t */\n\tget attributes() {\n\t\treturn this.open && this.open.attributes;\n\t}\n\n\t/**\n\t * Returns node’s start position in stream\n\t * @return {*}\n\t */\n\tget start() {\n\t\treturn this.open && this.open.start;\n\t}\n\n\t/**\n\t * Returns node’s start position in stream\n\t * @return {*}\n\t */\n\tget end() {\n\t\treturn this.close ? this.close.end : this.open && this.open.end;\n\t}\n\n\tget firstChild() {\n\t\treturn this.children[0];\n\t}\n\n\tget nextSibling() {\n\t\tconst ix = this.getIndex();\n\t\treturn ix !== -1 ? this.parent.children[ix + 1] : null;\n\t}\n\n\tget previousSibling() {\n\t\tconst ix = this.getIndex();\n\t\treturn ix !== -1 ? this.parent.children[ix - 1] : null;\n\t}\n\n\t/**\n\t * Returns current element’s index in parent list of child nodes\n\t * @return {Number}\n\t */\n\tgetIndex() {\n\t\treturn this.parent ? this.parent.children.indexOf(this) : -1;\n\t}\n\n\t/**\n\t * Adds given node as a child\n\t * @param {Node} node\n\t * @return {Node} Current node\n\t */\n\taddChild(node) {\n\t\tthis.removeChild(node);\n\t\tthis.children.push(node);\n\t\tnode.parent = this;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes given node from current node’s child list\n\t * @param  {Node} node\n\t * @return {Node} Current node\n\t */\n\tremoveChild(node) {\n\t\tconst ix = this.children.indexOf(node);\n\t\tif (ix !== -1) {\n\t\t\tthis.children.splice(ix, 1);\n\t\t\tnode.parent = null;\n\t\t}\n\n\t\treturn this;\n\t}\n}\n\n/**\n * A token factory method\n * @param  {StreamReader}   stream\n * @param  {Point|Function} start  Tokens’ start location or stream consumer\n * @param  {Point}          [end]  Tokens’ end location\n * @return {Token}\n */\nvar token = function(stream, start, end) {\n\treturn typeof start === 'function'\n\t\t? eatToken(stream, start)\n\t\t: new Token(stream, start, end);\n};\n\n/**\n * Consumes characters from given stream that matches `fn` call and returns it\n * as token, if consumed\n * @param  {StreamReader} stream\n * @param  {Function} test\n * @return {Token}\n */\nfunction eatToken(stream, test) {\n\tconst start = stream.pos;\n\tif (stream.eatWhile(test)) {\n\t\treturn new Token(stream, start, stream.pos);\n\t}\n\n\tstream.pos = start;\n}\n\n/**\n * A structure describing text fragment in content stream\n */\nclass Token {\n\t/**\n\t * @param {ContentStreamReader} stream\n\t * @param {Point} start         Tokens’ start location in content stream\n\t * @param {Point} end           Tokens’ end location in content stream\n\t */\n\tconstructor(stream, start, end) {\n\t\tthis.stream = stream;\n\t\tthis.start = start != null ? start : stream.start;\n\t\tthis.end   = end   != null ? end   : stream.pos;\n\t\tthis._value = null;\n\t}\n\n\t/**\n\t * Returns token textual value\n\t * NB implemented as getter to reduce unnecessary memory allocations for\n\t * strings that not required\n\t * @return {String}\n\t */\n\tget value() {\n\t\tif (this._value === null) {\n\t\t\tconst start = this.stream.start;\n\t\t\tconst end = this.stream.pos;\n\n\t\t\tthis.stream.start = this.start;\n\t\t\tthis.stream.pos = this.end;\n\t\t\tthis._value = this.stream.current();\n\n\t\t\tthis.stream.start = start;\n\t\t\tthis.stream.pos = end;\n\t\t}\n\n\t\treturn this._value;\n\t}\n\n\ttoString() {\n\t\treturn this.value;\n\t}\n\n\tvalueOf() {\n\t\treturn `${this.value} [${this.start}; ${this.end}]`;\n\t}\n}\n\nconst LANGLE  = 60;\nconst RANGLE  = 62;  // < and >\nconst LSQUARE = 91;\nconst RSQUARE = 93;  // [ and ]\nconst LROUND  = 40;\nconst RROUND  = 41;  // ( and )\nconst LCURLY  = 123;\nconst RCURLY  = 125; // { and }\n\nconst opt = { throws: true };\n\n/**\n * Consumes paired tokens (like `[` and `]`) with respect of nesting and embedded\n * quoted values\n * @param  {StreamReader} stream\n * @return {Token} A token with consumed paired character\n */\nvar eatPaired = function(stream) {\n\tconst start = stream.pos;\n\tconst consumed = eatPair(stream, LANGLE, RANGLE, opt)\n\t\t|| eatPair(stream, LSQUARE, RSQUARE, opt)\n\t\t|| eatPair(stream, LROUND,  RROUND,  opt)\n\t\t|| eatPair(stream, LCURLY,  RCURLY,  opt);\n\n\tif (consumed) {\n\t\treturn token(stream, start);\n\t}\n};\n\nconst SLASH$1        = 47;  // /\nconst EQUALS       = 61;  // =\nconst RIGHT_ANGLE$1  = 62;  // >\n\n/**\n * Consumes attributes from given stream\n * @param {StreamReader} stream\n * @return {Array} Array of consumed attributes\n */\nvar eatAttributes = function(stream) {\n\tconst result = [];\n\tlet name, value, attr;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isSpace);\n\t\tattr = { start: stream.pos };\n\n\t\t// A name could be a regular name or expression:\n\t\t// React-style – <div {...props}>\n\t\t// Angular-style – <div [ng-for]>\n\t\tif (attr.name = eatAttributeName(stream)) {\n\t\t\t// Consumed attribute name. Can be an attribute with name\n\t\t\t// or boolean attribute. The value can be React-like expression\n\t\t\tif (stream.eat(EQUALS)) {\n\t\t\t\tattr.value = eatAttributeValue(stream);\n\t\t\t} else {\n\t\t\t\tattr.boolean = true;\n\t\t\t}\n\t\t\tattr.end = stream.pos;\n\t\t\tresult.push(attr);\n\t\t} else if (isTerminator(stream.peek())) {\n\t\t\t// look for tag terminator in order to skip any other possible characters\n\t\t\t// (maybe junk)\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Consumes attribute name from current location\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatAttributeName(stream) {\n\treturn eatPaired(stream) || token(stream, isAttributeName);\n}\n\n/**\n * Consumes attribute value from given location\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatAttributeValue(stream) {\n\tconst start = stream.pos;\n\tif (eatQuoted(stream)) {\n\t\t// Should return token that points to unquoted value.\n\t\t// Use stream readers’ public API to traverse instead of direct\n\t\t// manipulation\n\t\tconst current = stream.pos;\n\t\tlet valueStart, valueEnd;\n\n\t\tstream.pos = start;\n\t\tstream.next();\n\t\tvalueStart = stream.start = stream.pos;\n\n\t\tstream.pos = current;\n\t\tstream.backUp(1);\n\t\tvalueEnd = stream.pos;\n\n\t\tconst result = token(stream, valueStart, valueEnd);\n\t\tstream.pos = current;\n\t\treturn result;\n\t}\n\n\treturn eatPaired(stream) || eatUnquoted(stream);\n}\n\n/**\n * Check if given code belongs to attribute name.\n * NB some custom HTML variations allow non-default values in name, like `*ngFor`\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAttributeName(code) {\n\treturn code !== EQUALS && !isTerminator(code) && !isSpace(code);\n}\n\n/**\n * Check if given code is tag terminator\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isTerminator(code) {\n\treturn code === RIGHT_ANGLE$1 || code === SLASH$1;\n}\n\n/**\n * Eats unquoted value from stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatUnquoted(stream) {\n\treturn token(stream, isUnquoted);\n}\n\n/**\n * Check if given character code is valid unquoted value\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isUnquoted(code) {\n\treturn !isNaN(code) && !isQuote(code) && !isSpace(code) && !isTerminator(code);\n}\n\nconst DASH        = 45; // -\nconst DOT         = 46; // .\nconst SLASH       = 47; // /\nconst COLON       = 58; // :\nconst LEFT_ANGLE  = 60; // <\nconst RIGHT_ANGLE = 62; // >\nconst UNDERSCORE  = 95; // _\n\n/**\n * Parses tag definition (open or close tag) from given stream state\n * @param {StreamReader} stream Content stream reader\n * @return {Object}\n */\nvar tag = function(stream) {\n\tconst start = stream.pos;\n\n\tif (stream.eat(LEFT_ANGLE)) {\n\t\tconst model = { type: stream.eat(SLASH) ? 'close' : 'open' };\n\n\t\tif (model.name = eatTagName(stream)) {\n\t\t\tif (model.type !== 'close') {\n\t\t\t\tmodel.attributes = eatAttributes(stream);\n\t\t\t\tstream.eatWhile(isSpace);\n\t\t\t\tmodel.selfClosing = stream.eat(SLASH);\n\t\t\t}\n\n\t\t\tif (stream.eat(RIGHT_ANGLE)) {\n\t\t\t\t// tag properly closed\n\t\t\t\treturn Object.assign(token(stream, start), model);\n\t\t\t}\n\t\t}\n\t}\n\n\t// invalid tag, revert to original position\n\tstream.pos = start;\n\treturn null;\n};\n\n/**\n * Eats HTML identifier (tag or attribute name) from given stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatTagName(stream) {\n\treturn token(stream, isTagName);\n}\n\n/**\n * Check if given character code can be used as HTML/XML tag name\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isTagName(code) {\n\treturn isAlphaNumeric(code)\n\t\t|| code === COLON // colon is used for namespaces\n\t\t|| code === DOT   // in rare cases declarative tag names may have dots in names\n\t\t|| code === DASH\n\t\t|| code === UNDERSCORE;\n}\n\n/**\n * Eats array of character codes from given stream\n * @param  {StreamReader} stream\n * @param  {Number[]} codes  Array of character codes\n * @return {Boolean}\n */\nfunction eatArray(stream, codes) {\n\tconst start = stream.pos;\n\n\tfor (let i = 0; i < codes.length; i++) {\n\t\tif (!stream.eat(codes[i])) {\n\t\t\tstream.pos = start;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstream.start = start;\n\treturn true;\n}\n\n/**\n * Consumes section from given string which starts with `open` character codes\n * and ends with `close` character codes\n * @param  {StreamReader} stream\n * @param  {Number[]} open\n * @param  {Number[]} close\n * @return {Boolean}  Returns `true` if section was consumed\n */\nfunction eatSection(stream, open, close, allowUnclosed) {\n\tconst start = stream.pos;\n\tif (eatArray(stream, open)) {\n\t\t// consumed `<!--`, read next until we find ending part or reach the end of input\n\t\twhile (!stream.eof()) {\n\t\t\tif (eatArray(stream, close)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tstream.next();\n\t\t}\n\n\t\t// unclosed section is allowed\n\t\tif (allowUnclosed) {\n\t\t\treturn true;\n\t\t}\n\n\t\tstream.pos = start;\n\t\treturn false;\n\t}\n\n\t// unable to find section, revert to initial position\n\tstream.pos = start;\n\treturn null;\n}\n\n/**\n * Converts given string into array of character codes\n * @param  {String} str\n * @return {Number[]}\n */\nfunction toCharCodes(str) {\n\treturn str.split('').map(ch => ch.charCodeAt(0));\n}\n\nconst open  = toCharCodes('<!--');\nconst close = toCharCodes('-->');\n\n/**\n * Consumes HTML comment from given stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nvar comment = function(stream) {\n\tconst start = stream.pos;\n\tif (eatSection(stream, open, close, true)) {\n\t\tconst result = token(stream, start);\n\t\tresult.type = 'comment';\n\t\treturn result;\n\t}\n\n\treturn null;\n};\n\nconst open$1  = toCharCodes('<![CDATA[');\nconst close$1 = toCharCodes(']]>');\n\n/**\n * Consumes CDATA from given stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nvar cdata = function(stream) {\n\tconst start = stream.pos;\n\tif (eatSection(stream, open$1, close$1, true)) {\n\t\tconst result = token(stream, start);\n\t\tresult.type = 'cdata';\n\t\treturn result;\n\t}\n\n\treturn null;\n};\n\nconst defaultOptions = {\n\t/**\n\t * Expect XML content in searching content. It alters how should-be-empty\n\t * elements are treated: for example, in XML mode parser will try to locate\n\t * closing pair for `<br>` tag\n\t * @type {Boolean}\n\t */\n\txml: false,\n\n\tspecial: ['script', 'style'],\n\n\t/**\n\t * List of elements that should be treated as empty (e.g. without closing tag)\n\t * in non-XML syntax\n\t * @type {Array}\n\t */\n\tempty: ['img', 'meta', 'link', 'br', 'base', 'hr', 'area', 'wbr']\n};\n\n/**\n * Parses given content into a DOM-like structure\n * @param  {String|StreamReader} content\n * @param  {Object} options\n * @return {Node}\n */\nfunction parse(content, options) {\n\toptions = Object.assign({}, defaultOptions, options);\n\tconst stream = typeof content === 'string'\n\t\t? new StreamReader(content)\n\t\t: content;\n\n\tconst root = new Node(stream, 'root');\n\tconst empty = new Set(options.empty);\n\tconst special = options.special.reduce(\n\t\t(map, name) => map.set(name, toCharCodes(`</${name}>`)), new Map());\n\tconst isEmpty = (token, name) =>\n\t\ttoken.selfClosing || (!options.xml && empty.has(name));\n\n\tlet m, node, name, stack = [root];\n\n\twhile (!stream.eof()) {\n\t\tif (m = match(stream)) {\n\t\t\tname = getName(m);\n\n\t\t\tif (m.type === 'open') {\n\t\t\t\t// opening tag\n\t\t\t\tnode = new Node(stream, 'tag', m);\n\t\t\t\tlast(stack).addChild(node);\n\t\t\t\tif (special.has(name)) {\n\t\t\t\t\tnode.close = consumeSpecial(stream, special.get(name));\n\t\t\t\t} else if (!isEmpty(m, name)) {\n\t\t\t\t\tstack.push(node);\n\t\t\t\t}\n\t\t\t} else if (m.type === 'close') {\n\t\t\t\t// closing tag, find it’s matching opening tag\n\t\t\t\tfor (let i = stack.length - 1; i > 0; i--) {\n\t\t\t\t\tif (stack[i].name.toLowerCase() === name) {\n\t\t\t\t\t\tstack[i].close = m;\n\t\t\t\t\t\tstack = stack.slice(0, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlast(stack).addChild(new Node(stream, m.type, m));\n\t\t\t}\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn root;\n}\n\n/**\n * Matches known token in current state of given stream\n * @param  {ContentStreamReader} stream\n * @return {Token}\n */\nfunction match(stream) {\n\t// fast-path optimization: check for `<` code\n\tif (stream.peek() === 60 /* < */) {\n\t\treturn comment(stream) || cdata(stream) || tag(stream);\n\t}\n}\n\n/**\n * @param  {StreamReader} stream\n * @param  {Number[]} codes\n * @return {Token}\n */\nfunction consumeSpecial(stream, codes) {\n\tconst start = stream.pos;\n\tlet m;\n\n\twhile (!stream.eof()) {\n\t\tif (eatArray(stream, codes)) {\n\t\t\tstream.pos = stream.start;\n\t\t\treturn tag(stream);\n\t\t}\n\t\tstream.next();\n\t}\n\n\tstream.pos = start;\n\treturn null;\n}\n\n/**\n * Returns name of given matched token\n * @param  {Token} tag\n * @return {String}\n */\nfunction getName(tag$$1) {\n\treturn tag$$1.name ? tag$$1.name.value.toLowerCase() : `#${tag$$1.type}`;\n}\n\nfunction last(arr) {\n\treturn arr[arr.length - 1];\n}\n\nexport { defaultOptions, match };export default parse;\n","'use strict';\n\nimport { containsPos } from '../utils';\n\n/**\n * A syntax-specific model container, used to get unified access to underlying\n * parsed document\n */\nexport default class SyntaxModel {\n\t/**\n\t * @param  {Object} dom      Parsed document tree\n\t * @param  {String} type     Type of document (html, stylesheet, etc.)\n\t * @param  {String} [syntax] Optional document syntax like html, xhtml or xml\n\t */\n\tconstructor(dom, type, syntax) {\n\t\tthis.dom = dom;\n\t\tthis.type = type;\n\t\tthis.syntax = syntax;\n\t}\n\n\t/**\n\t * Returns best matching node for given point\n\t * @param  {CodeMirror.Pos}   pos\n\t * @param  {Boolean} [exclude] Exclude node’s start and end positions from\n\t *                             search\n\t * @return {Node}\n\t */\n\tnodeForPoint(pos, exclude) {\n\t\tlet ctx = this.dom.firstChild;\n\t\tlet found = null;\n\n\t\twhile (ctx) {\n\t\t\tif (containsPos(range(ctx), pos, exclude)) {\n\t\t\t\t// Found matching tag. Try to find deeper, more accurate match\n\t\t\t\tfound = ctx;\n\t\t\t\tctx = ctx.firstChild;\n\t\t\t} else {\n\t\t\t\tctx = ctx.nextSibling;\n\t\t\t}\n\t\t}\n\n\t\treturn found;\n\t}\n}\n\nfunction range(node) {\n\treturn {\n\t\tfrom: node.start,\n\t\tto: node.end\n\t};\n}\n","'use strict';\n\nimport parseHTML from '@emmetio/html-matcher';\nimport SyntaxModel from './syntax-model';\nimport StreamReader from '../stream-reader';\n\n/**\n * Creates DOM-like model for given text editor\n * @param  {CodeMirror} editor\n * @param  {String}     syntax\n * @return {Node}\n */\nexport default function create(editor, syntax) {\n\tconst stream = new StreamReader(editor);\n\tconst xml = syntax === 'xml';\n\n\ttry {\n\t\treturn new SyntaxModel(parseHTML(stream, { xml }), 'html', syntax || 'html');\n\t} catch (err) {\n\t\tconsole.warn(err);\n\t}\n}\n","'use babel';\n\nimport parseHTML from './html';\n\nexport default function getModel(editor) {\n\tconst syntax = getSyntax(editor);\n\treturn parseHTML(editor, syntax);\n}\n\nexport function getCachedModel(editor) {\n\tif (!editor.state._emmetModel) {\n\t\teditor.state._emmetModel = getModel(editor);\n\t}\n\n\treturn editor.state._emmetModel;\n}\n\nexport function resetCachedModel(editor) {\n\teditor.state._emmetModel = null;\n}\n\n/**\n * Returns parser-supported syntax of given editor (like 'html', 'css' etc.).\n * Returns `null` if editor’s syntax is unsupported\n * @param  {CodeMirror} editor\n * @return {String}\n */\nfunction getSyntax(editor) {\n\tconst mode = editor.getMode();\n\n\tif (mode.name === 'htmlmixed') {\n\t\treturn 'html';\n\t}\n\n\treturn mode.name === 'xml' ? mode.configuration : mode.name;\n}\n","'use strict';\n\nimport { containsPos } from './utils';\n\nconst openTagMark = 'emmet-open-tag';\nconst closeTagMark = 'emmet-close-tag';\n\n/**\n * Finds matching tag pair for given position in editor\n * @param  {CodeMirror} editor\n * @param  {CodeMirror.Pos} pos\n * @return {Object}\n */\nexport default function matchTag(editor, pos) {\n\tpos = pos || editor.getCursor();\n\n\t// First, check if there are tag markers in editor\n\tconst marked = getMarkedTag(editor);\n\n\t// If marks found, validate them: make sure cursor is either in open\n\t// or close tag\n\tif (marked) {\n\t\tif (containsPos(marked.open.find(), pos)) {\n\t\t\t// Point is inside open tag, make sure if there’s a closing tag,\n\t\t\t// it matches open tag content\n\t\t\tif (!marked.close || text(editor, marked.open) === text(editor, marked.close)) {\n\t\t\t\treturn marked;\n\t\t\t}\n\t\t} else if (marked.close) {\n\t\t\t// There’s a close tag, make sure pointer is inside it and it matches\n\t\t\t// open tag\n\t\t\tif (containsPos(marked.close.find(), pos) && text(editor, marked.open) === text(editor, marked.close)) {\n\t\t\t\treturn marked;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Markers are not valid anymore, remove them\n\tclearTagMatch(editor);\n\n\t// Find new tag pair from parsed HTML model and mark them\n\tconst node = findTagPair(editor, pos);\n\tif (node && node.type === 'tag') {\n\t\treturn {\n\t\t\topen: createTagMark(editor, node.open.name, openTagMark),\n\t\t\tclose: node.close && createTagMark(editor, node.close.name, closeTagMark)\n\t\t};\n\t}\n}\n\nexport function getMarkedTag(editor) {\n\tlet open, close;\n\teditor.getAllMarks().forEach(mark => {\n\t\tif (mark.className === openTagMark) {\n\t\t\topen = mark;\n\t\t} else if (mark.className === closeTagMark) {\n\t\t\tclose = mark;\n\t\t}\n\t});\n\n\treturn open ? { open, close } : null;\n}\n\n/**\n * Removes all matched tag pair markers from editor\n * @param  {CodeMirror} editor\n */\nexport function clearTagMatch(editor) {\n\teditor.getAllMarks().forEach(mark => {\n\t\tif (mark.className === openTagMark || mark.className === closeTagMark) {\n\t\t\tmark.clear();\n\t\t}\n\t});\n}\n\n/**\n * Finds tag pair (open and close, if any) form parsed HTML model of given editor\n * @param  {CodeMirror} editor\n * @param  {CodeMirror.Pos} pos\n * @return {Object}\n */\nexport function findTagPair(editor, pos) {\n\tconst model = editor.getEmmetDocumentModel();\n\treturn model && model.nodeForPoint(pos || editor.getCursor());\n}\n\nfunction createTagMark(editor, tag, className) {\n\treturn editor.markText(tag.start, tag.end, {\n\t\tclassName,\n\t\tinclusiveLeft: true,\n\t\tinclusiveRight: true,\n\t\tclearWhenEmpty: false\n\t});\n}\n\nfunction text(editor, mark) {\n\tconst range = mark.find();\n\treturn range ? editor.getRange(range.from, range.to) : '';\n}\n","'use strict';\n\nimport { getMarkedTag, clearTagMatch } from './match-tag';\nimport { containsPos } from './utils';\n\nexport default function renameTag(editor, obj) {\n\tconst tag = getMarkedTag(editor);\n\tconst pos = obj.from;\n\n\tif (!tag) {\n\t\treturn;\n\t}\n\n\tif (containsPos(tag.open.find(), pos) && tag.close) {\n\t\t// Update happened inside open tag, update close tag as well\n\t\tupdateTag(editor, tag.open, tag.close);\n\t} else if (tag.close && containsPos(tag.close.find(), pos)) {\n\t\t// Update happened inside close tag, update open tag as well\n\t\tupdateTag(editor, tag.close, tag.open);\n\t}\n}\n\nexport function updateTag(editor, source, dest) {\n\tconst name = text(editor, source);\n\tconst range = dest.find();\n\tconst m = name.match(/[\\w:\\-]+/);\n\tconst newName = !name ? '' : (m && m[0]);\n\n\tif (newName != null) {\n\t\tif (editor.getRange(range.from, range.to) !== newName) {\n\t\t\teditor.replaceRange(newName, range.from, range.to);\n\t\t}\n\t} else {\n\t\t// User entered something that wasn’t a valid tag name.\n\t\tclearTagMatch(editor);\n\t}\n}\n\nfunction text(editor, mark) {\n\tconst range = mark.find();\n\treturn range ? editor.getRange(range.from, range.to) : '';\n}\n","class Snippet {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n\nclass SnippetsStorage {\n    constructor(data) {\n        this._string = new Map();\n        this._regexp = new Map();\n        this._disabled = false;\n\n        this.load(data);\n    }\n\n    get disabled() {\n        return this._disabled;\n    }\n\n    /**\n     * Disables current store. A disabled store always returns `undefined`\n     * on `get()` method\n     */\n    disable() {\n        this._disabled = true;\n    }\n\n    /**\n     * Enables current store.\n     */\n    enable() {\n        this._disabled = false;\n    }\n\n    /**\n     * Registers a new snippet item\n     * @param {String|Regexp} key\n     * @param {String|Function} value\n     */\n    set(key, value) {\n        if (typeof key === 'string') {\n            key.split('|').forEach(k => this._string.set(k, new Snippet(k, value)));\n        } else if (key instanceof RegExp) {\n            this._regexp.set(key, new Snippet(key, value));\n        } else {\n            throw new Error('Unknow snippet key: ' + key);\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns a snippet matching given key. It first tries to find snippet\n     * exact match in a string key map, then tries to match one with regexp key\n     * @param {String} key\n     * @return {Snippet}\n     */\n    get(key) {\n        if (this.disabled) {\n            return undefined;\n        }\n\n        if (this._string.has(key)) {\n            return this._string.get(key);\n        }\n\n        const keys = Array.from(this._regexp.keys());\n        for (let i = 0, il = keys.length; i < il; i++) {\n            if (keys[i].test(key)) {\n                return this._regexp.get(keys[i]);\n            }\n        }\n    }\n\n    /**\n     * Batch load of snippets data\n     * @param {Object|Map} data\n     */\n    load(data) {\n        this.reset();\n        if (data instanceof Map) {\n            data.forEach((value, key) => this.set(key, value));\n        } else if (data && typeof data === 'object') {\n            Object.keys(data).forEach(key => this.set(key, data[key]));\n        }\n    }\n\n    /**\n     * Clears all stored snippets\n     */\n    reset() {\n        this._string.clear();\n        this._regexp.clear();\n    }\n\n    /**\n     * Returns all available snippets from given store\n     */\n    values() {\n        if (this.disabled) {\n            return [];\n        }\n        \n        const string = Array.from(this._string.values());\n        const regexp = Array.from(this._regexp.values());\n        return string.concat(regexp);\n    }\n}\n\n/**\n * A snippets registry. Contains snippets, separated by store and sorted by\n * priority: a store with higher priority takes precedence when resolving snippet\n * for given key\n */\nclass SnippetsRegistry {\n    /**\n     * Creates snippets registry, filled with given `data`\n     * @param {Object|Array} data Registry snippets. If array is given, adds items\n     * from array in order of precedence, registers global snippets otherwise\n     */\n    constructor(data) {\n        this._registry = [];\n\n        if (Array.isArray(data)) {\n            data.forEach((snippets, level) => this.add(level, snippets));\n        } else if (typeof data === 'object') {\n            this.add(data);\n        }\n    }\n\n    /**\n     * Return store for given level\n     * @param {Number} level\n     * @return {SnippetsStorage}\n     */\n    get(level) {\n        for (let i = 0; i < this._registry.length; i++) {\n            const item = this._registry[i];\n            if (item.level === level) {\n                return item.store;\n            }\n        }\n    }\n\n    /**\n     * Adds new store for given level\n     * @param {Number} [level] Store level (priority). Store with higher level\n     * takes precedence when resolving snippets\n     * @param {Object} [snippets] A snippets data for new store\n     * @return {SnipetsStorage}\n     */\n    add(level, snippets) {\n        if (level != null && typeof level === 'object') {\n            snippets = level;\n            level = 0;\n        }\n\n        const store = new SnippetsStorage(snippets);\n\n        // remove previous store from same level\n        this.remove(level);\n\n        this._registry.push({level, store});\n        this._registry.sort((a, b) => b.level - a.level);\n\n        return store;\n    }\n\n    /**\n     * Remove registry with given level or store\n     * @param {Number|SnippetsStorage} data Either level or snippets store\n     */\n    remove(data) {\n        this._registry = this._registry\n        .filter(item => item.level !== data && item.store !== data);\n    }\n\n    /**\n     * Returns snippet from registry that matches given name\n     * @param {String} name\n     * @return {Snippet}\n     */\n    resolve(name) {\n        for (let i = 0; i < this._registry.length; i++) {\n            const snippet = this._registry[i].store.get(name);\n            if (snippet) {\n                return snippet;\n            }\n        }\n    }\n\n    /**\n     * Returns all available snippets from current registry. Snippets with the\n     * same key are resolved by their storage priority.\n     * @param {Object} options\n     * @param {Object} options.type Return snippets only of given type: 'string'\n     * or 'regexp'. Returns all snippets if not defined\n     * @return {Array}\n     */\n    all(options) {\n        options = options || {};\n        const result = new Map();\n\n        const fillResult = snippet => {\n            const type = snippet.key instanceof RegExp ? 'regexp' : 'string';\n            if ((!options.type || options.type === type) && !result.has(snippet.key)) {\n                result.set(snippet.key, snippet);\n            }\n        };\n\n        this._registry.forEach(item => {\n            item.store.values().forEach(fillResult);\n        });\n\n        return Array.from(result.values());\n    }\n\n    /**\n     * Removes all stores from registry\n     */\n    clear() {\n        this._registry.length = 0;\n    }\n}\n\nexport default SnippetsRegistry;\n","/**\n * A streaming, character code-based string reader\n */\nclass StreamReader {\n\tconstructor(string, start, end) {\n\t\tif (end == null && typeof string === 'string') {\n\t\t\tend = string.length;\n\t\t}\n\n\t\tthis.string = string;\n\t\tthis.pos = this.start = start || 0;\n\t\tthis.end = end;\n\t}\n\n\t/**\n\t * Returns true only if the stream is at the end of the file.\n\t * @returns {Boolean}\n\t */\n\teof() {\n\t\treturn this.pos >= this.end;\n\t}\n\n\t/**\n\t * Creates a new stream instance which is limited to given `start` and `end`\n\t * range. E.g. its `eof()` method will look at `end` property, not actual\n\t * stream end\n\t * @param  {Point} start\n\t * @param  {Point} end\n\t * @return {StreamReader}\n\t */\n\tlimit(start, end) {\n\t\treturn new this.constructor(this.string, start, end);\n\t}\n\n\t/**\n\t * Returns the next character code in the stream without advancing it.\n\t * Will return NaN at the end of the file.\n\t * @returns {Number}\n\t */\n\tpeek() {\n\t\treturn this.string.charCodeAt(this.pos);\n\t}\n\n\t/**\n\t * Returns the next character in the stream and advances it.\n\t * Also returns <code>undefined</code> when no more characters are available.\n\t * @returns {Number}\n\t */\n\tnext() {\n\t\tif (this.pos < this.string.length) {\n\t\t\treturn this.string.charCodeAt(this.pos++);\n\t\t}\n\t}\n\n\t/**\n\t * `match` can be a character code or a function that takes a character code\n\t * and returns a boolean. If the next character in the stream 'matches'\n\t * the given argument, it is consumed and returned.\n\t * Otherwise, `false` is returned.\n\t * @param {Number|Function} match\n\t * @returns {Boolean}\n\t */\n\teat(match) {\n\t\tconst ch = this.peek();\n\t\tconst ok = typeof match === 'function' ? match(ch) : ch === match;\n\n\t\tif (ok) {\n\t\t\tthis.next();\n\t\t}\n\n\t\treturn ok;\n\t}\n\n\t/**\n\t * Repeatedly calls <code>eat</code> with the given argument, until it\n\t * fails. Returns <code>true</code> if any characters were eaten.\n\t * @param {Object} match\n\t * @returns {Boolean}\n\t */\n\teatWhile(match) {\n\t\tconst start = this.pos;\n\t\twhile (!this.eof() && this.eat(match)) {}\n\t\treturn this.pos !== start;\n\t}\n\n\t/**\n\t * Backs up the stream n characters. Backing it up further than the\n\t * start of the current token will cause things to break, so be careful.\n\t * @param {Number} n\n\t */\n\tbackUp(n) {\n\t\tthis.pos -= (n || 1);\n\t}\n\n\t/**\n\t * Get the string between the start of the current token and the\n\t * current stream position.\n\t * @returns {String}\n\t */\n\tcurrent() {\n\t\treturn this.substring(this.start, this.pos);\n\t}\n\n\t/**\n\t * Returns substring for given range\n\t * @param  {Number} start\n\t * @param  {Number} [end]\n\t * @return {String}\n\t */\n\tsubstring(start, end) {\n\t\treturn this.string.slice(start, end);\n\t}\n\n\t/**\n\t * Creates error object with current stream state\n\t * @param {String} message\n\t * @return {Error}\n\t */\n\terror(message) {\n\t\tconst err = new Error(`${message} at char ${this.pos + 1}`);\n\t\terr.originalMessage = message;\n\t\terr.pos = this.pos;\n\t\terr.string = this.string;\n\t\treturn err;\n\t}\n}\n\nexport default StreamReader;\n","var html = {\n\t\"a\": \"a[href]\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"style\": \"style\",\n\t\"script\": \"script[!src]\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:button\": \"input[type=button value]\",\n    \"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+meta:edge+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar css = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${1});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:flex-start|flex-end|center|space-between|space-around|stretch\",\n\t\"ai\": \"align-items:flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:${1:time}\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:#${1:000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:#${1:000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:#${1:000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:#${1:000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:#${1:000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:#${1:000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:#${1:000}\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters({$0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fz\": \"font-size\",\n\t\"fza\": \"font-size-adjust\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:flex-start|flex-end|center|space-between|space-around\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:#${1:000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar index = { html, css };\n\nexport default index;\n","'use strict';\n\nimport { findMarker, clearMarkers } from '../abbreviation-marker';\nimport { extractAbbreviation, expandAndInsert } from '../expand-abbreviation';\n\n/**\n * Expand abbreviation command\n * @param  {CodeMirror} editor\n */\nexport default function(editor) {\n\tif (editor.somethingSelected()) {\n\t\treturn editor.constructor.Pass;\n\t}\n\n\tconst pos = editor.getCursor();\n\tconst marker = findMarker(editor, pos);\n\n\tlet result = false;\n\n\t// Handle two possible options: expand abbreviation from Emmet marker that\n\t// matches given location or extract & expand abbreviation from cursor\n\t// position. The last one may happen if either `markeEmmetAbbreviation`\n\t// option is turned off or user moved cursor away from Emmet marker and\n\t// tries to expand another abbreviation\n\n\tif (marker) {\n\t\tresult = expandAndInsert(editor, marker.model.ast, marker.find());\n\t} else {\n\t\tconst abbrData = extractAbbreviation(editor, pos);\n\t\tif (abbrData) {\n\t\t\tconst range = {\n\t\t\t\tfrom: {\n\t\t\t\t\tline: pos.line,\n\t\t\t\t\tch: abbrData.location\n\t\t\t\t},\n\t\t\t\tto: {\n\t\t\t\t\tline: pos.line,\n\t\t\t\t\tch: abbrData.location + abbrData.abbreviation.length\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tresult = expandAndInsert(editor, abbrData.abbreviation, range);\n\t\t}\n\t}\n\n\tclearMarkers(editor);\n\n\t// If no abbreviation was expanded, allow editor to handle different\n\t// action for keyboard shortcut (Tab key mostly)\n\treturn result || editor.constructor.Pass;\n}\n","'use strict';\n\nimport { getIndentation } from '../utils';\n\n/**\n * Inserts formatted line tag between tags\n * @param  {CodeMirror} editor\n */\nexport default function(editor) {\n\tconst cursor = editor.getCursor();\n\tconst mode = editor.getModeAt(cursor);\n\n\tif (mode.name === 'xml') {\n\t\tconst next = Object.assign({}, cursor, { ch: cursor.ch + 1 });\n\t\tconst left = editor.getTokenAt(cursor);\n\t\tconst right = editor.getTokenAt(Object.assign({}, cursor, { ch: cursor.ch + 1 }));\n\n\t\tif (left.type === 'tag bracket' && left.string === '>'\n\t\t\t&& right.type === 'tag bracket' && right.string === '</') {\n\t\t\t\tconst matchIndent = editor.getLine(cursor.line).match(/^\\s+/);\n\t\t\t\tconst curIndent = matchIndent ? matchIndent[0] : '';\n\t\t\t\tconst indent = getIndentation(editor);\n\n\t\t\t\t// Insert formatted line break\n\t\t\t\tconst before = `\\n${curIndent}${indent}`;\n\t\t\t\tconst after = `\\n${curIndent}`;\n\t\t\t\teditor.replaceRange(before + after, cursor, cursor);\n\n\t\t\t\t// Position cursor\n\t\t\t\tconst startIx = editor.indexFromPos(cursor);\n\t\t\t\tconst newCursor = editor.posFromIndex(startIx + before.length);\n\t\t\t\teditor.setCursor(newCursor);\n\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\n\treturn editor.constructor.Pass;\n}\n","/**\n * A streaming, character code-based string reader\n */\nclass StreamReader {\n\tconstructor(string, start, end) {\n\t\tif (end == null && typeof string === 'string') {\n\t\t\tend = string.length;\n\t\t}\n\n\t\tthis.string = string;\n\t\tthis.pos = this.start = start || 0;\n\t\tthis.end = end;\n\t}\n\n\t/**\n\t * Returns true only if the stream is at the end of the file.\n\t * @returns {Boolean}\n\t */\n\teof() {\n\t\treturn this.pos >= this.end;\n\t}\n\n\t/**\n\t * Creates a new stream instance which is limited to given `start` and `end`\n\t * range. E.g. its `eof()` method will look at `end` property, not actual\n\t * stream end\n\t * @param  {Point} start\n\t * @param  {Point} end\n\t * @return {StreamReader}\n\t */\n\tlimit(start, end) {\n\t\treturn new this.constructor(this.string, start, end);\n\t}\n\n\t/**\n\t * Returns the next character code in the stream without advancing it.\n\t * Will return NaN at the end of the file.\n\t * @returns {Number}\n\t */\n\tpeek() {\n\t\treturn this.string.charCodeAt(this.pos);\n\t}\n\n\t/**\n\t * Returns the next character in the stream and advances it.\n\t * Also returns <code>undefined</code> when no more characters are available.\n\t * @returns {Number}\n\t */\n\tnext() {\n\t\tif (this.pos < this.string.length) {\n\t\t\treturn this.string.charCodeAt(this.pos++);\n\t\t}\n\t}\n\n\t/**\n\t * `match` can be a character code or a function that takes a character code\n\t * and returns a boolean. If the next character in the stream 'matches'\n\t * the given argument, it is consumed and returned.\n\t * Otherwise, `false` is returned.\n\t * @param {Number|Function} match\n\t * @returns {Boolean}\n\t */\n\teat(match) {\n\t\tconst ch = this.peek();\n\t\tconst ok = typeof match === 'function' ? match(ch) : ch === match;\n\n\t\tif (ok) {\n\t\t\tthis.next();\n\t\t}\n\n\t\treturn ok;\n\t}\n\n\t/**\n\t * Repeatedly calls <code>eat</code> with the given argument, until it\n\t * fails. Returns <code>true</code> if any characters were eaten.\n\t * @param {Object} match\n\t * @returns {Boolean}\n\t */\n\teatWhile(match) {\n\t\tconst start = this.pos;\n\t\twhile (!this.eof() && this.eat(match)) {}\n\t\treturn this.pos !== start;\n\t}\n\n\t/**\n\t * Backs up the stream n characters. Backing it up further than the\n\t * start of the current token will cause things to break, so be careful.\n\t * @param {Number} n\n\t */\n\tbackUp(n) {\n\t\tthis.pos -= (n || 1);\n\t}\n\n\t/**\n\t * Get the string between the start of the current token and the\n\t * current stream position.\n\t * @returns {String}\n\t */\n\tcurrent() {\n\t\treturn this.substring(this.start, this.pos);\n\t}\n\n\t/**\n\t * Returns substring for given range\n\t * @param  {Number} start\n\t * @param  {Number} [end]\n\t * @return {String}\n\t */\n\tsubstring(start, end) {\n\t\treturn this.string.slice(start, end);\n\t}\n\n\t/**\n\t * Creates error object with current stream state\n\t * @param {String} message\n\t * @return {Error}\n\t */\n\terror(message) {\n\t\tconst err = new Error(`${message} at char ${this.pos + 1}`);\n\t\terr.originalMessage = message;\n\t\terr.pos = this.pos;\n\t\terr.string = this.string;\n\t\treturn err;\n\t}\n}\n\nexport default StreamReader;\n","/**\n * A streaming, character code-based string reader\n */\nclass StreamReader {\n\tconstructor(string, start, end) {\n\t\tif (end == null && typeof string === 'string') {\n\t\t\tend = string.length;\n\t\t}\n\n\t\tthis.string = string;\n\t\tthis.pos = this.start = start || 0;\n\t\tthis.end = end;\n\t}\n\n\t/**\n\t * Returns true only if the stream is at the end of the file.\n\t * @returns {Boolean}\n\t */\n\teof() {\n\t\treturn this.pos >= this.end;\n\t}\n\n\t/**\n\t * Creates a new stream instance which is limited to given `start` and `end`\n\t * range. E.g. its `eof()` method will look at `end` property, not actual\n\t * stream end\n\t * @param  {Point} start\n\t * @param  {Point} end\n\t * @return {StreamReader}\n\t */\n\tlimit(start, end) {\n\t\treturn new this.constructor(this.string, start, end);\n\t}\n\n\t/**\n\t * Returns the next character code in the stream without advancing it.\n\t * Will return NaN at the end of the file.\n\t * @returns {Number}\n\t */\n\tpeek() {\n\t\treturn this.string.charCodeAt(this.pos);\n\t}\n\n\t/**\n\t * Returns the next character in the stream and advances it.\n\t * Also returns <code>undefined</code> when no more characters are available.\n\t * @returns {Number}\n\t */\n\tnext() {\n\t\tif (this.pos < this.string.length) {\n\t\t\treturn this.string.charCodeAt(this.pos++);\n\t\t}\n\t}\n\n\t/**\n\t * `match` can be a character code or a function that takes a character code\n\t * and returns a boolean. If the next character in the stream 'matches'\n\t * the given argument, it is consumed and returned.\n\t * Otherwise, `false` is returned.\n\t * @param {Number|Function} match\n\t * @returns {Boolean}\n\t */\n\teat(match) {\n\t\tconst ch = this.peek();\n\t\tconst ok = typeof match === 'function' ? match(ch) : ch === match;\n\n\t\tif (ok) {\n\t\t\tthis.next();\n\t\t}\n\n\t\treturn ok;\n\t}\n\n\t/**\n\t * Repeatedly calls <code>eat</code> with the given argument, until it\n\t * fails. Returns <code>true</code> if any characters were eaten.\n\t * @param {Object} match\n\t * @returns {Boolean}\n\t */\n\teatWhile(match) {\n\t\tconst start = this.pos;\n\t\twhile (!this.eof() && this.eat(match)) {}\n\t\treturn this.pos !== start;\n\t}\n\n\t/**\n\t * Backs up the stream n characters. Backing it up further than the\n\t * start of the current token will cause things to break, so be careful.\n\t * @param {Number} n\n\t */\n\tbackUp(n) {\n\t\tthis.pos -= (n || 1);\n\t}\n\n\t/**\n\t * Get the string between the start of the current token and the\n\t * current stream position.\n\t * @returns {String}\n\t */\n\tcurrent() {\n\t\treturn this.substring(this.start, this.pos);\n\t}\n\n\t/**\n\t * Returns substring for given range\n\t * @param  {Number} start\n\t * @param  {Number} [end]\n\t * @return {String}\n\t */\n\tsubstring(start, end) {\n\t\treturn this.string.slice(start, end);\n\t}\n\n\t/**\n\t * Creates error object with current stream state\n\t * @param {String} message\n\t * @return {Error}\n\t */\n\terror(message) {\n\t\tconst err = new Error(`${message} at char ${this.pos + 1}`);\n\t\terr.originalMessage = message;\n\t\terr.pos = this.pos;\n\t\terr.string = this.string;\n\t\treturn err;\n\t}\n}\n\nexport default StreamReader;\n","'use strict';\n\nimport StreamReader from '@emmetio/stream-reader';\nimport { comparePos } from './utils';\n\nconst LINE_END = 10; // \\n\n\n/**\n * A stream reader for CodeMirror editor\n */\nexport default class CodeMirrorStreamReader extends StreamReader {\n\t/**\n\t * @param  {CodeMirror}       editor\n\t * @param  {CodeMirror.Pos}   [pos]\n\t * @param  {CodeMirror.Range} [limit]\n\t */\n\tconstructor(editor, pos, limit) {\n\t\tsuper();\n\t\tconst CodeMirror = editor.constructor;\n\t\tthis.editor = editor;\n\t\tthis.start = this.pos = pos || CodeMirror.Pos(0, 0);\n\n\t\tconst lastLine = editor.lastLine();\n\t\tthis._eof = limit ? limit.to   : CodeMirror.Pos(lastLine, this._lineLength(lastLine));\n\t\tthis._sof = limit ? limit.from : CodeMirror.Pos(0, 0);\n\t}\n\n\t/**\n\t * Returns true only if the stream is at the beginning of the file.\n\t * @returns {Boolean}\n\t */\n\tsof() {\n\t\treturn comparePos(this.pos, this._sof) <= 0;\n\t}\n\n\t/**\n\t * Returns true only if the stream is at the end of the file.\n\t * @returns {Boolean}\n\t */\n\teof() {\n\t\treturn comparePos(this.pos, this._eof) >= 0;\n\t}\n\n\t/**\n\t * Creates a new stream instance which is limited to given `start` and `end`\n\t * points for underlying buffer\n\t * @param  {CodeMirror.Pos} start\n\t * @param  {CodeMirror.Pos} end\n\t * @return {CodeMirrorStreamReader}\n\t */\n\tlimit(from, to) {\n\t\treturn new this.constructor(this.editor, from, { from, to });\n\t}\n\n\t/**\n\t * Returns the next character code in the stream without advancing it.\n\t * Will return NaN at the end of the file.\n\t * @returns {Number}\n\t */\n\tpeek() {\n\t\tconst { line, ch } = this.pos;\n\t\tconst lineStr = this.editor.getLine(this.pos.line);\n\t\treturn ch < lineStr.length ? lineStr.charCodeAt(ch) : LINE_END;\n\t}\n\n\t/**\n\t * Returns the next character in the stream and advances it.\n\t * Also returns NaN when no more characters are available.\n\t * @returns {Number}\n\t */\n\tnext() {\n\t\tif (!this.eof()) {\n\t\t\tconst code = this.peek();\n\t\t\tthis.pos = Object.assign({}, this.pos, { ch: this.pos.ch + 1 });\n\n\t\t\tif (this.pos.ch >= this._lineLength(this.pos.line)) {\n\t\t\t\tthis.pos.line++;\n\t\t\t\tthis.pos.ch = 0;\n\t\t\t}\n\n\t\t\tif (this.eof()) {\n\t\t\t\t// handle edge case where position can move on next line\n\t\t\t\t// after EOF\n\t\t\t\tthis.pos = Object.assign({}, this._eof);\n\t\t\t}\n\n\t\t\treturn code;\n\t\t}\n\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * Backs up the stream n characters. Backing it up further than the\n\t * start of the current token will cause things to break, so be careful.\n\t * @param {Number} n\n\t */\n\tbackUp(n) {\n\t\tconst CodeMirror = this.editor.constructor;\n\n\t\tlet { line, ch } = this.pos;\n\t\tch -= (n || 1);\n\n\t\twhile (line >= 0 && ch < 0) {\n\t\t\tline--;\n\t\t\tch += this._lineLength(line);\n\t\t}\n\n\t\tthis.pos = line < 0 || ch < 0\n\t\t\t? CodeMirror.Pos(0, 0)\n\t\t\t: CodeMirror.Pos(line, ch);\n\n\t\treturn this.peek();\n\t}\n\n\t/**\n\t * Get the string between the start of the current token and the\n\t * current stream position.\n\t * @returns {String}\n\t */\n\tcurrent() {\n\t\treturn this.substring(this.start, this.pos);\n\t}\n\n\t/**\n\t * Returns contents for given range\n\t * @param  {Point} from\n\t * @param  {Point} to\n\t * @return {String}\n\t */\n\tsubstring(from, to) {\n\t\treturn this.editor.getRange(from, to);\n\t}\n\n\t/**\n\t * Creates error object with current stream state\n\t * @param {String} message\n\t * @return {Error}\n\t */\n\terror(message) {\n\t\tconst err = new Error(`${message} at line ${this.pos.line}, column ${this.pos.ch}`);\n\t\terr.originalMessage = message;\n\t\terr.pos = this.pos;\n\t\terr.string = this.string;\n\t\treturn err;\n\t}\n\n\t/**\n\t * Returns length of given line, including line ending\n\t * @param  {Number} line\n\t * @return {Number}\n\t */\n\t_lineLength(line) {\n\t\tconst isLast = line === this.editor.lastLine();\n\t\treturn this.editor.getLine(line).length + (isLast ? 0 : 1);\n\t}\n}\n","'use strict';\n\nimport emmetExpandAbbreviation from './lib/commands/expand-abbreviation';\nimport emmetInsertLineBreak from './lib/commands/formatted-line-break';\nimport {\n\tmarkOnEditorChange, findMarker, markAbbreviation, clearMarkers\n} from './lib/abbreviation-marker';\nimport autocompleteProvider from './lib/autocomplete';\nimport { extractAbbreviation, parseAbbreviation, createAbbreviationModel } from './lib/expand-abbreviation';\nimport getModel, { getCachedModel, resetCachedModel } from './lib/model/index';\nimport matchTag, { clearTagMatch } from './lib/match-tag';\nimport renameTag from './lib/rename-tag';\n\nconst commands = { emmetExpandAbbreviation, emmetInsertLineBreak };\n\n/**\n * Registers Emmet extension on given CodeMirror constructor.\n * This file is designed to be imported somehow into the app (CommonJS, ES6,\n * Rollup/Webpack/whatever). If you simply want to add a <script> into your page\n * that registers Emmet extension on global CodeMirror constructor, use\n * `browser.js` instead\n */\nexport default function registerEmmetExtension(CodeMirror) {\n\t// Register Emmet commands\n\tObject.assign(CodeMirror.commands, commands);\n\n\t// Defines options that allows abbreviation marking in text editor\n\tCodeMirror.defineOption('markEmmetAbbreviation', true, (editor, value) => {\n\t\tif (value) {\n\t\t\teditor.on('change', markOnEditorChange);\n\t\t} else {\n\t\t\teditor.off('change', markOnEditorChange);\n\t\t\tclearMarkers(editor);\n\t\t}\n\t});\n\n\tCodeMirror.defineOption('autoRenameTags', true, (editor, value) => {\n\t\tvalue ? editor.on('change', renameTag) : editor.off('change', renameTag);\n\t});\n\n\tCodeMirror.defineOption('markTagPairs', false, (editor, value) => {\n\t\tif (value) {\n\t\t\teditor.on('cursorActivity', matchTag);\n\t\t\teditor.on('change', resetCachedModel);\n\t\t} else {\n\t\t\teditor.off('cursorActivity', matchTag);\n\t\t\teditor.off('change', resetCachedModel);\n\t\t\tresetCachedModel(editor);\n\t\t\tclearTagMatch(editor);\n\t\t}\n\t});\n\n\t// Additional options for Emmet, for Expand Abbreviation action mostly:\n\t// https://github.com/emmetio/expand-abbreviation/blob/master/index.js#L26\n\tCodeMirror.defineOption('emmet', {});\n\n\t/**\n\t * Returns Emmet completions for context from `pos` position.\n\t * Abbreviations are calculated for marked abbreviation at given position.\n\t * If no parsed abbreviation marker is available and `force` argument is\n\t * given, tries to mark abbreviation and populate completions list again.\n\t * @param  {CodeMirror.Pos} [pos]\n\t * @param  {Boolean}        [force]\n\t * @return {EmmetCompletion[]}\n\t */\n\tCodeMirror.defineExtension('getEmmetCompletions', function(pos, force) {\n\t\tconst editor = this;\n\t\tif (typeof pos === 'boolean') {\n\t\t\tforce = pos;\n\t\t\tpos = null;\n\t\t}\n\n\t\tlet abbrRange, list;\n\n\t\tpos = pos || editor.getCursor();\n\t\tif (editor.getOption('markEmmetAbbreviation')) {\n\t\t\t// Get completions from auto-inserted marker\n\t\t\tconst marker = findMarker(editor, pos) || (force && markAbbreviation(editor, pos, true));\n\t\t\tif (marker) {\n\t\t\t\tabbrRange = marker.find();\n\t\t\t\tlist = autocompleteProvider(editor, marker.model, abbrRange.from, pos);\n\t\t\t}\n\t\t} else {\n\t\t\t// No abbreviation auto-marker, try to extract abbreviation from given\n\t\t\t// cursor location\n\t\t\tconst extracted = extractAbbreviation(editor, pos);\n\t\t\tif (extracted) {\n\t\t\t\tconst model = createAbbreviationModel(extracted.abbreviation, editor);\n\t\t\t\tif (model) {\n\t\t\t\t\tabbrRange = {\n\t\t\t\t\t\tfrom: { line: pos.line, ch: extracted.location },\n\t\t\t\t\t\tto: { line: pos.line, ch: extracted.location + extracted.abbreviation.length }\n\t\t\t\t\t};\n\t\t\t\t\tlist = autocompleteProvider(editor, model, abbrRange.from, pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (list && list.length) {\n\t\t\treturn {\n\t\t\t\tfrom: abbrRange.from,\n\t\t\t\tto: abbrRange.to,\n\t\t\t\tlist\n\t\t\t};\n\t\t}\n\t});\n\n\t/**\n\t * Returns valid Emmet abbreviation and its location in editor from given\n\t * position\n\t * @param  {CodeMirror.Pos} [pos] Position from which abbreviation should be\n\t *                                extracted. If not given, current cursor\n\t *                                position is used\n\t * @return {Object} Object with `abbreviation` and `location` properties\n\t * or `null` if there’s no valid abbreviation\n\t */\n\tCodeMirror.defineExtension('getEmmetAbbreviation', function(pos) {\n\t\tconst editor = this;\n\t\tpos = pos || editor.getCursor();\n\t\tconst marker = findMarker(editor, pos);\n\n\t\tif (marker) {\n\t\t\treturn {\n\t\t\t\tabbreviation: marker.model.abbreviation,\n\t\t\t\tast: marker.model.ast,\n\t\t\t\tlocation: marker.find().from,\n\t\t\t\tfromMarker: true\n\t\t\t};\n\t\t}\n\n\t\tconst extracted = extractAbbreviation(editor, pos);\n\t\tif (extracted) {\n\t\t\ttry {\n\t\t\t\treturn {\n\t\t\t\t\tabbreviation: extracted.abbreviation,\n\t\t\t\t\tast: parseAbbreviation(extracted.abbreviation, editor),\n\t\t\t\t\tlocation: { line: pos.line,  ch: extracted.location },\n\t\t\t\t\tfromMarker: false\n\t\t\t\t};\n\t\t\t} catch (err) {\n\t\t\t\t// Will throw if abbreviation is invalid\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t});\n\n\tCodeMirror.defineExtension('findEmmetMarker', function(pos) {\n\t\treturn findMarker(this, pos || this.getCursor());\n\t});\n\n\tCodeMirror.defineExtension('getEmmetDocumentModel', function() {\n\t\tconst editor = this;\n\t\treturn editor.getOption('markTagPairs')\n\t\t\t? getCachedModel(editor)\n\t\t\t: getModel(editor);\n\t});\n}\n","'use strict';\n\nimport registerEmmetExtension from './extension.js';\n\nif (typeof CodeMirror !== 'undefined') {\n\tregisterEmmetExtension(CodeMirror);\n}\n"],"names":["isQuote","c","SINGLE_QUOTE","DOUBLE_QUOTE","eatQuoted","stream","const","start","pos","quote","prev","sol","peek","ESCAPE","eatAttribute","eatAttributeWithQuotedValue","eatAttributeWithUnquotedValue","eat","EQUALS","eatIdent","eatWhile","isUnquotedValue","isIdent","COLON","isAlpha","isNumber","isWhiteSpace","SPACE","TAB","extractAbbreviation","line","lookAhead","Math","min","length","max","offsetPastAutoClosed","let","StreamReader","stack","isCloseBrace","push","isOpenBrace","pop","bracePairs","get","has","SQUARE_BRACE_R","CURLY_BRACE_R","isAtHTMLTag","isAbbreviation","abbreviation","slice","replace","location","charCodeAt","arr","value","indexOf","specialChars","SQUARE_BRACE_L","ROUND_BRACE_L","CURLY_BRACE_L","ROUND_BRACE_R","strcase","string","type","toUpperCase","toLowerCase","createAttribute","name","Attribute","options","normalize","str","String","trim","uniqueClass","item","i","code","from","to","isAlphaNumeric","isSpace","eatPair","open","close","Object","assign","defaultOptions$1","ch","eof","next","escape","throws","error","fromCharCode","parseAttributeName","EXCL","implied","DOT$1","boolean","attr","keys","eatUnquoted","isUnquoted","ATTR_OPEN","ATTR_CLOSE","eatName","isName","current","parse","root","Node","ctx","groupStack","GROUP_START","GROUP_END","node","consumeElement","appendChild","OP_SIBLING","OP_CHILD","OP_CLIMB","parent","lastGroup","repeat","consumeRepeat","firstChild","groupCtx","last","unroll","count","clone","walk","insertBefore","resolveNode","registry","Set","resolve","snippet","tree","add","delete","childTarget","findDeepestNode","merge","remove","selfClosing","mergeAttributes","mergeClassNames","attrMap","Map","attrs","attributes","set","a","removeAttribute","newAttrs","Array","values","setAttribute","classNames","classList","addClass","children","resolveImplicitName","parentName","elementMap","inlineElements","findUnescapedTokens","token","result","tlen","size","len","map","ix","range","replaceRanges","ranges","r","substring","substr","applyNumbering$1","repeater","findRepeater","replaceNumbering","forEach","copy","getAttribute","replaceAttribute","replaceNumberingRanges","getNumberingRanges","numberingToken","reduce","out","range$$1","test","lastRange","unescapeString","_value","prepare","amount","implicit","index","insert","content","isArray","updated","insertContent","setNodeContent","join","inserted","insertContentIntoPlaceholder","child","state","replaced","replacePlaceholder","_state","placeholder","caret","hasAttribute","reUrl","reProto","reEmail","expandClassNames","cl","modifier","expandShortNotation","lookup","prefix","m","originalClass","match","reElement","getBlockName","element","reModifier","createBlockLookup","find","blockCandidates1","blockCandidates2","depth","filter","oldName","newName","replaceVariables","variables","replaceInNode","il","replaceInString","model","createModel","offset","output","v","reVariable","tokens","exec","validMatches","field","fields","cleanString","consumeField","FieldString","mark","createToken","ordered","order","end","sort","b","DOLLAR","consumeIndex","Field","OPEN_BRACE","consumePlaceholder","CLOSE_BRACE","Number","splitByLines","text","split","render","formatter","defaultField","fieldState","fieldsRenderer","getFieldsModel","run","nodes","notGroup","outNode","OutputNode","toString","isGroup","parseFields","largestIndex","template","data","lastPos","replacer","left","right","TOKEN_OPEN","TOKEN_CLOSE","TOKEN","isFirstChild","isRoot","isPseudoSnippet","isTextOnly","handlePseudoSnippet","fieldsModel","findLowestIndexField","parts","splitFieldsModel","renderFields","constructor","html","profile","comment","commentOptions","setFormatting","formatAttributes","selfClose","commentNode","shouldFormatNode","indent","getIndentLevel","newline","beforeOpen","beforeText","hasInnerFormatting","beforeClose","isInline","shouldFormatInline","childIndex","nextSibling","previousSibling","adjacentInline","before","after","isInlineElement","nodeName","attrName","attribute","attrValue","skip","level","enabled","trigger","indentFormat","defaultNodeOptions","getIndentLevel$1","NAME","SELF_CLOSE","getAttributes","omitName","PRIMARY_ATTRS","defaultAttrOptions","primary","secondary","reId","reClass","isBoolean","SECONDARY_ATTRS","haml","nodeOptions","updateFormatting","formatNodeValue","reNl","lines","maxLength","pad","slim","attributeWrap","secondaryAttrs","none","booleanAttr","updateFormatting$1","formatNodeValue$1","isInline$1","reNl$1","pug","updateFormatting$2","formatNodeValue$2","reNl$2","supports","syntax","supportedSyntaxed","isHex","isShortHex","hex","toShortHex","num","toHex","isAlphaNumericWord","isAlphaWord","eatNumber","negative","DASH$1","hadDot","consumed","isKeyword","DASH$2","isVariableName","consumeArgumentList","LBRACE","arg","argsList","consumeArgument","RBRACE","COMMA","CSSValue","consumeNumericValue","consumeColor","consumeQuoted","consumeKeywordOrFunction","kw","consumeKeyword","args","FunctionCall","consumeIdent","isIdentPrefix","consumeValue","unit","DASH","AT","sum","n","nest","snippets","snippetsSort","cur","property","addDependency","key","isKeyword$1","splitValue","convertToCSSSnippets","cssSnippets","all","findBestMatch","resolveAsProperty","resolveAsSnippet","setNodeAsText","abbr","keywords","globalKeywords","isNumericValue","resolveNumericValue","getUnmatchedPart","defaulValue","items","matchedItem","maxScore","score","stringScore","getScoringPart","tokenTypeOf","unitAliases","unitlessProperties","css","defaultOptions","injectFields","stringifyAttribute","afterOpen","format","between","afterText","lastChild","fieldsAmount","concat","shift","delta","shortHex","syntaxFormat","getFormat","rand","floor","random","sample","iterations","choice","val","sentence","words","capitalize","word","insertCommas","hasComma","totalCommas","paragraph","dict","wordCount","startWithCommon","totalWords","common","isRepeating","expand$1","parse$1","parseAbbreviation","use","transform","addons","resolveSnippets","resolveVariables","expand$2","parse$2","format$1","parseAbbreviation$1","resolveSnippets$1","loremGenerator","reLorem","lang","lorem","expand$$1","createOptions","isStylesheet","parse$$1","createSnippetsRegistry","SnippetsRegistry","snippetsRegistryFactory","createProfile","defaultVariables","stylesheetSyntaxes","Profile","detectSyntax","editor","mode","getModeAt","getCursor","isSupported","emmetOpt","getOption","knownSyntaxes","hasAutoActivateContext","autoActivationContext","getIndentation","repeatString","normalizeText","indentation","tabs","removeFields","containsPos","exclude","comparePos","expandAbbreviation","expand","editorField","getExpandOptions","extract","getLine","createAbbreviationModel","ast","err","expandAndInsert","expanded","cursorMarked","newSelectionSize","cursorMark","matchIndent","newCursorPos","operation","replaceRange","startIx","indexFromPos","newCursor","posFromIndex","setSelection","setCursor","selfClosingStyle","configuration","snippetsFromOptions","stylesheetSnippets","markupSnippets","markOnEditorChange","marker","findMarker","isValidMarker","clearMarkers","markAbbreviation","markers","findMarksAt","className","emmetMarkerClass","forced","extracted","allowedForAutoActivation","markText","inclusiveRight","clearWhenEmpty","getAllMarks","clear","rootNode","getRange","getMarkupCompletions","abbrModel","abbrPos","cursorPos","abbrRange","EmmetCompletion","getMarkupPrefix","prefixRange","completions","getSnippetCompletions","preview","getStylesheetCompletions","getStylesheetPrefix","emmetCompletions","cache","expandOpt","getPrefix","eatToken","Token","eatAttributeName","eatPaired","isAttributeName","eatAttributeValue","valueStart","valueEnd","backUp","isTerminator","RIGHT_ANGLE$1","SLASH$1","isNaN","eatTagName","isTagName","DOT","UNDERSCORE","eatArray","codes","eatSection","allowUnclosed","toCharCodes","empty","special","getName","addChild","consumeSpecial","xml","cdata","tag","tag$$1","create","SyntaxModel","parseHTML","console","warn","getModel","getSyntax","getCachedModel","_emmetModel","resetCachedModel","getMode","matchTag","marked","getMarkedTag","clearTagMatch","findTagPair","createTagMark","openTagMark","closeTagMark","getEmmetDocumentModel","nodeForPoint","inclusiveLeft","renameTag","obj","updateTag","source","dest","this","ok","tagCase","attributeCase","attributeQuotes","formatSkip","formatForce","inlineBreak","compactBooleanAttributes","booleanAttributes","quoteChar","isBooleanAttribute","Snippet","SnippetsStorage","_string","_regexp","_disabled","load","prototypeAccessors","disabled","disable","enable","k","RegExp","Error","reset","regexp","_registry","store","fillResult","valueOf","previous","_attributes","attributesMap","curAttr","curAttribute","newValue","splice","clearAttributes","hasClass","removeClass","insertAt","newNode","refNode","removeChild","deep","fn","_level","arguments","apply","opt","limit","message","originalMessage","opt$1","consumeTextNode","reAttributeName","consumeAttributes","p","ul","ol","table","tr","tbody","thead","tfoot","colgroup","select","optgroup","audio","video","object","implicitTags","resolveImplicitTag","applyNumbering","bem","jsx","reSupporterNames","xsl","supportedAddons","addonOpt","appliedAddons","defaultFieldsRenderer","_fieldsRenderer","afterClose","indentText","nl","_wrap","round","curly","square","base","Color","alpha","raw","g","parseInt","short","toRGB","toFixed","NumericValue","Keyword","QuotedString","ch1","ch2","found","acronym","abbrLength","stringLength","j","CSSSnippet","dependencies","dep","candidates","deps","e","x","scss","less","sass","stylus","a:link","a:mail","acr|acronym","basefont","br","frame","hr","bdo","bdo:r","bdo:l","col","link","link:css","link:print","link:favicon","link:touch","link:rss","link:atom","link:im|link:import","meta","meta:utf","meta:vp","meta:compat","meta:edge","meta:redirect","style","script","script:src","img","img:s|img:srcset","img:z|img:sizes","picture","src|source","src:sc|source:src","src:s|source:srcset","src:t|source:type","src:z|source:sizes","src:m|source:media","src:mt|source:media:type","src:mz|source:media:sizes","src:zt|source:sizes:type","iframe","embed","param","area","area:d","area:c","area:r","area:p","form","form:get","form:post","label","input","inp","input:h|input:hidden","input:t|input:text","input:search","input:email","input:url","input:p|input:password","input:datetime","input:date","input:datetime-local","input:month","input:week","input:time","input:tel","input:number","input:color","input:c|input:checkbox","input:r|input:radio","input:range","input:f|input:file","input:s|input:submit","input:i|input:image","input:b|input:button","input:reset","isindex","select:d|select:disabled","opt|option","textarea","marquee","menu:c|menu:context","menu:t|menu:toolbar","html:xml","keygen","command","btn:s|button:s|button:submit","btn:r|button:r|button:reset","btn:d|button:d|button:disabled","fst:d|fset:d|fieldset:d|fieldset:disabled","bq","fig","figc","pic","ifr","emb","cap","colg","fst","btn","optg","tarea","leg","sect","art","hdr","ftr","adr","dlg","prog","mn","tem","fset","datag","datal","kg","det","cmd","ri:d|ri:dpr","ri:v|ri:viewport","ri:a|ri:art","ri:t|ri:type","!!!","doc","!|html:5","cc:ie","cc:noie","@f","@ff","@i|@import","@kf","@m|@media","ac","ai","anim","animdel","animdir","animdur","animfm","animic","animn","animps","animtf","ap","as","bd","bdb","bdbc","bdbi","bdbk","bdbli","bdblrs","bdbri","bdbrrs","bdbs","bdbw","bdc","bdci","bdcl","bdf","bdi","bdl","bdlc","bdlen","bdli","bdls","bdlw","bdr","bdrc","bdri","bdrs","bdrst","bdrw","bds","bdsp","bdt","bdtc","bdti","bdtli","bdtlrs","bdtri","bdtrrs","bdts","bdtw","bdw","bfv","bg","bga","bgbk","bgc","bgcp","bgi","bgo","bgp","bgpx","bgpy","bgr","bgsz","bxsh","bxsz","cm","cnt","coi","colm","colmc","colmf","colmg","colmr","colmrc","colmrs","colmrw","colms","colmw","cor","cp","cps","d","ec","f","fef","fem","femp","fems","ff","fl","fs","fsm","fv","fw","fx","fxb","fxd","fxf","fxg","fxsh","fxw","fz","fza","h","jc","l","lg","lh","lis","lisi","lisp","list","lts","mah","mar","maw","mb","mih","mir","miw","ml","mr","mt","olc","olo","ols","olw","op","ord","ori","orp","ov","ovs","ovx","ovy","pb","pgba","pgbb","pgbi","pl","pr","pt","q","qen","qru","rsz","t","ta","tal","tbl","td","te","th","ti","tj","tov","trf","trfo","trfs","trs","trsde","trsdu","trsp","trstf","tsh","tt","tw","us","va","w","whs","whsc","wid","wm","wob","wos","wow","z","zom","latin","ru","sp","langs","skipCommon","registrySnippets","defaultSnippets","Boolean","locale","charset","stylesheetAutoActivationContext","tokenType","getTokenTypeAt","somethingSelected","Pass","abbrData","cursor","getTokenAt","curIndent","_inserted","getIndex","prototypeAccessors$1","eatAttributes","open$1","close$1","dom","CodeMirrorStreamReader","super","CodeMirror","Pos","lastLine","_eof","_lineLength","_sof","sof","lineStr","NaN","isLast","commands","emmetExpandAbbreviation","emmetInsertLineBreak","defineOption","on","off","defineExtension","force","autocompleteProvider","fromMarker"],"mappings":"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"}